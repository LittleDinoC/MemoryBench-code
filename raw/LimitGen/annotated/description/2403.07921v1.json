{
    "title": "Merino: Entropy-driven Design for Generative Language Models on IoT Devices",
    "abstract": "Generative Large Language Models (LLMs) stand as a revolutionary advancement in the modern era of artificial intelligence (AI).\nHowever, directly deploying LLMs in resource-constrained hardware, such as Internet-of-Things (IoT) devices, is difficult due to their high computational cost.\nIn this paper, we propose a novel information-entropy framework for designing mobile-friendly generative language models.\nOur key design paradigm is to maximize the entropy of transformer decoders within the given computational budgets.\nThe whole design procedure involves solving a mathematical programming (MP) problem, which can be done on the CPU within minutes, making it nearly zero-cost.\nWe evaluate our designed models, termed MeRino, across nine NLP downstream tasks, showing their competitive performance against the state-of-the-art autoregressive transformer models under the mobile setting.\nNotably, MeRino achieves similar or better zero performance compared to the 350M parameter OPT while being 4.9 faster on NVIDIA Jetson Nano with 5.5 reduction in model size.\nCode will be made available soon.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "The Transformer architecture, originally introduced in [1  ###reference_b1###], has revolutionized the field of natural language processing (NLP).\nIt has become the de-facto building block in many large-scale pre-trained language models (LLMs) [2  ###reference_b2###, 3  ###reference_b3###, 4  ###reference_b4###, 5  ###reference_b5###, 6  ###reference_b6###, 7  ###reference_b7###].\nEspecially, Generative Large-scale Language Models (LLMs), exemplified by GPT [4  ###reference_b4###, 5  ###reference_b5###] and LLaMA [7  ###reference_b7###], have gained considerable popularity in recent studies.\nYet, such models are without a doubt expensive to train and deploy. For instance, GPT-175B contains over 175 billion parameters, rendering it unsuitable for direct deployment on resource-constrained devices, such as mobile phones or Internet-of-Things (IoT) hardware.\nConsequently, there exists a substantial demand for developing lightweight language models that can be deployed to mobile systems with small memory footprints and low compute power.\nA key challenge of designing mobile-friendly language models is that the hardware configuration varies from device to device.\nTherefore, it is difficult to design a one-fits-all model that satisfies all requirements.\nTo this end, it is critical to customize an optimized language model backbone under different computational budgets.\nA conventional approach is to use knowledge distillation (KD) [8  ###reference_b8###] which distills larger language models into pre-defined smaller backbones [9  ###reference_b9###, 10  ###reference_b10###, 11  ###reference_b11###].\nHowever, there is no guarantee that these pre-defined, fixed-size backbones are optimal on the given device. Another more flexible approach is to use\nAutoML [12  ###reference_b12###] or neural architecture search (NAS) [13  ###reference_b13###, 14  ###reference_b14###, 15  ###reference_b15###] to optimize the transformer backbone.\nHowever, these methods are usually computationally demanding, which involves super-net [16  ###reference_b16###, 17  ###reference_b17###] training or even brute-force grid search. Such processes often consume considerable GPU hours and leave large carbon footprints.\nMoreover, training super-nets is a non-trivial task as child architectures often interfere with each other which leads to performance degradation, as reported in [18  ###reference_b18###].\nIn this paper, we present an entropy-driven framework to design lightweight variants of generative language models tailored for resource-constrained devices.\nOur method leverages recent advancements in information theory and theoretical deep learning which formulate autoregressive language models as information processing systems parameterized by structural parameters such as network widths and depths.\nThen, the Maximum Entropy Principle [19  ###reference_b19###] is applied to optimize the network architecture design. More specifically, our design aims to find the optimal configuration of network structure parameters, including depths/widths/embedding dimensions, such that the network entropy is maximized under the given computational budgets, such as parameter size and FLOPs.\nAlbeit the Maximum Entropy Principle is conceptually simple, a direct application encounters two technical challenges.\nFirst, the notion of entropy for a transformer backbone is not well-defined in deep learning literature.\nTo overcome this hurdle, we propose to use subspace entropy spanned by the network parameters at random initialization as model entropy.\nThe computation of subspace entropy can be accelerated via table lookup therefore, it is highly efficient.\nSecond, we find that naively maximizing the entropy will lead to an over-deep transformer backbone that is difficult to train.\nTo address this issue, we propose to preserve the model trainability during the architecture design.\nThen an Evolutionary Algorithm (EA) is utilized to optimize the structural parameters of the transformer backbone (e.g., number of heads, channels, embedding dimensions, etc.).\nFinally, we can design a family of optimized, Mobile-friendly geneRative language models, or MeRino for short, on various mobile devices at nearly zero cost.\nThe key contributions of this work are summarized as follows:\nTo the best of our knowledge, we first present an entropy-driven framework to address the challenge of designing efficient generative language models for resource-constrained devices at nearly zero cost.\nOur framework leverages the Maximum Entropy Principle and considers both the entropy and trainability of language models to optimize transformer architectures given computation budgets.\nExperimental results show that MeRino achieves competitive performance against the state-of-the-art LLMs, including OPT and Pythia models. Notably, our models exhibit improved parameters, computation, and throughput efficiency on mobile devices."
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Related Work",
            "text": "Generative statistical language models (LLMs) have emerged as the standard solution to a wide range of NLP tasks. They are generally pre-trained on large-scale corpora in self-supervised manners to learn the contextual structure of natural language. Unlike previous language models, LLMs consist of only transformer decoder layers and exhibit outstanding ability to scale up and impressive zero-shot generalization performances. GPT-3 [5  ###reference_b5###], in particular, pushed the boundaries of casual language models by scaling up the model size to 175 billion parameters and pre-training on a large corpus of over 570 GB plain texts. In the pursuit of democratizing and fostering reproducible research in LLMs, Meta AI recently released Open Pre-trained Transformers (OPT) [6  ###reference_b6###], a suite of decoder-only models, ranging from 125 M to 175 B parameters. In this work, our scope is generative, or decoder-only transformer-based language models and we aim to design such LLMs suitable for mobile devices with limited memory space and compute power. One of the most widely studied techniques in compressing LLMs is knowledge distillation (KD) [8  ###reference_b8###]. BERT-PKD [11  ###reference_b11###] distill BERT into smaller students using knowledge transfer in both final output and hidden states in multiple intermediate layers. TinyBERT [20  ###reference_b20###] adopts a layer-wise distillation strategy for BERT at both the pre-training and fine-tuning stages. [9  ###reference_b9###] investigates numerous KD techniques to compress GPT-2 models by layer truncation. Despite achieving promising results, the above KD-based methods can only distill LLMs into a fixed-size model, which is not suitable for deployment on diverse and heterogeneous devices. In this work, orthogonal to KD, which focuses primarily on the training and fine-tuning stage, our proposed method emphasizes designing lightweight transformer architectures with various parameter sizes and FLOPs to meet different hardware constraints. Due to its success in computer vision (CV), neural architecture search (NAS) has recently gained attention in the NLP community. NAS-BERT [14  ###reference_b14###] trains a supernet to efficiently search for masked language models which are compressed versions of the standard BERT. AutoTinyBERT [15  ###reference_b15###] further reduces overall computation cost over NAS-BERT by adopting a linear search space. For encoder-decoder architectures, HAT [13  ###reference_b13###] uses the Once-For-All [16  ###reference_b16###] approach and performs a search on sub-samples of the supernet that inherits weights to estimate downstream task accuracy. LTS [21  ###reference_b21###] proposes using non-embedding parameters in decoders as a proxy score to predict the perplexity performance of generative LLMs. However, the aforementioned methods are mostly data-dependent and incur heavy computation costs. Moreover, it is difficult for researchers to understand why specific architectures are preferred by the algorithm and what theoretical insight we can learn from these results. In this work, we plan to explore the architecture design of autoregressive language models in a principled way with clear theoretical motivation and human explainability. Information theory recently has emerged as a powerful tool for studying deep neural networks [22  ###reference_b22###, 23  ###reference_b23###, 24  ###reference_b24###, 25  ###reference_b25###]. Several previous studies [22  ###reference_b22###, 23  ###reference_b23###] have attempted to establish a connection between the information entropy and the neural network architectures. For instance, [22  ###reference_b22###] tries to interpret the learning ability of deep neural networks using subspace entropy reduction. [23  ###reference_b23###] investigates the information bottleneck in deep architectures and explores the entropy distribution and information flow in deep neural networks. Additionally, [24  ###reference_b24###, 25  ###reference_b25###] focus on designing high-performance convolutional neural networks (CNNs) via maximizing multi-level entropy. Yet, to the best of our knowledge, there is still no published work using information entropy to design efficient decoder-only transformer backbones for language models."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "Methodology",
            "text": "In this section, we begin by presenting some preliminary details on autoregressive transformer models.\nNext, we introduce our novel definition of network entropy for transformer models.\nMoreover, we demonstrate that the untrained subspace entropy positively correlates with the model performance after training.\nFinally, we present our entropy-driven design procedure, which solves a constrained mathematical programming problem using the Evolutionary Algorithm (EA).\nTransformers have gained prominence due to their ability to model complex functions that involve long-range dependencies.\nDecoder-only, or autoregressive transformers, operate by predicting the next element in a sequence based on the preceding elements.\nA standard autoregressive transformer comprises an embedding layer to project sequences of tokens to hidden dimensions and stacks of transformer layers to capture long-term dependencies between input tokens using the self-attention mechanism.\nA transformer layer includes two main components: a multi-head attention (MHA) module and a position-wise feed-forward network (FFN).\nThe MHA module facilitates capturing contextual information by attending to different positions within the input sequence, while the FFN performs element-wise transformations to introduce non-linearity and improve representational capacity.\nMulti-head attention (MHA) is a crucial component within the transformer architecture that enables the model to selectively attend to different segments of the input sequence.\nThis mechanism involves projecting the input sequence into multiple attention heads, each of which calculates an independent attention distribution.\nIn MHA computation, there are specifically four main matrices involved: attention matrices  and output project matrix . Given the output of previous layers  as input, the attention function is formulated as:\nwhere , , and  represent queries, keys, and values, respectively.\nMHA is defined by concatenating  attention heads and producing outputs as follows:\nIn addition, the transformer layer adopts residual connection and layer normalization on top of MHA to compute the final outputs.\nIn addition to the MHA, each transformer layer includes a feed-forward network (FFN).\nThe FFN applies two point-wise fully connected layers followed by a non-linear activation function, such as ReLU. Operations within FFN can be formulated as follows:\nSimilarly, the FFN also incorporates residual connections and layer normalization to compute the final outputs:\nExpressiveness in Deep Network  From the perspective of information theory [19  ###reference_b19###, 26  ###reference_b26###], deep neural networks can be regarded as information systems, and their performance is closely related to the expressive power of such networks.\nThe notion of entropy is often used to measure such expressiveness through intermediate feature maps [25  ###reference_b25###] in convolutional neural networks (CNNs).\nIn the case of transformers, we propose to define the entropy of transformers from the perspective of parameter subspaces.\nSuppose that  presents a linear mapping with  input channels and  output channels. The elements of  are randomly sampled from the standard Gaussian distribution . According to previous works [22  ###reference_b22###], the subspace spanned by the random linear mapping  has\nwhere ,  is the -th largest singular value of \nand  is a small constant.\nFor an -layer network , we define the network entropy  by accumulating the entropy of matrices in each layer as the following:\nEffectiveness in Deep Network  The entropy measures the expressiveness of the deep neural network, which is positively correlated with the network performance [25  ###reference_b25###].\nHowever, directly maximizing the above-defined entropy leads to the creation of over-deep networks, since according to Eq. (8  ###reference_###), the expressivity (entropy) grows exponentially faster in depth (number of layers ), than in width (dimension of ).\nFor an over-deep network, a small perturbation in low-level layers of the network will lead to an exponentially large perturbation in the high-level output of the network [27  ###reference_b27###].\nDuring the back-propagation process, the gradient flow often cannot effectively propagate through the entire network.\nThough recent works have attempted to alleviate the trainability issues by revising initialization strategies [28  ###reference_b28###, 29  ###reference_b29###], adding skip connections [30  ###reference_b30###, 31  ###reference_b31###], or proposing better architectures [32  ###reference_b32###, 33  ###reference_b33###], training over-deep networks still remains a rather challenging problem.\nTo verify the negative impact when the network is over-deep, in Table 1  ###reference_###, we conduct experiments of training two transformer architectures with a similar parameter size of 40 M.\nOne model, referred to as the ‘Wide’ model, consists of only one layer and an embedding dimension of 256.\nThe other model, referred to as the ‘Deep’ model, consists of 24 layers but only with an embedding dimension of 64.\nBoth models are trained under the same setting until convergence. We observe that even though the ‘deep’ network has much higher entropy, it obtains worse perplexity performance after training than the ‘wide’ network.\nThis observation aligns with the common belief that over-deep networks hinder effective information propagation [27  ###reference_b27###] and are difficult to train and optimize [34  ###reference_b34###].\nTo address the potential trainability issues, we propose adding additional constraints to control the depth-width ratio of networks. Specifically, we adopt the term effectiveness  from the work [27  ###reference_b27###] and define it as follows:\nHere,  is the effective width of a -layer network and  is a scaling factor to control  within the range of 0 and 1. To enforce the above constraint, we revise Eq. (8  ###reference_###) as follows:\nCompared to the previous subspace entropy definition, Eq. (10  ###reference_###) penalizes networks with larger depth-to-width ratios (higher ).\nThis constraint helps alleviate potential trainability issues by promoting a more balanced depth-width ratio in the network architecture.\nBy considering both expressiveness (entropy) and effectiveness (the depth-width ratio), we aim to design more capable and trainable models.\nEntropy of Transformers  Consider a -layer transformer model with embedding dimension  and FFN dimension , according to Theorem 1 in  [35  ###reference_b35###], the depth-width sufficiency behavior satisfied a logarithmic condition in transformer models.\nSubsequently, we propose to define the effective width of MHA and FFN and their corresponding entropy as:\nIn practice, we find that using weighted entropy for MHA and FFN gives us a more reliable indicator for model performance. Therefore, we define the total entropy of the transformer model as linear combinations of the MHA and FFN entropy:\nwhere  are tunable hyperparameters.\nFast Entropy Approximation  Given the above definitions, we can easily calculate entropy for any transformer model.\nHowever, performing singular value decomposition (SVD) is a costly operation. For large models, it sometimes requires minutes to run SVD, which inhibits a zero-cost design.\nTo accelerate the entropy computation, we build an entropy lookup table to approximate the total entropy of a given transformer model.\nThe lookup table is built through a pre-computation process that considers all possible combinations of expected entropy values for different dimensions.\nThis step incurs only a one-time cost and the resulting lookup table can be shared across multiple experiments.\nWith the lookup table in place, we can efficiently calculate the entropy of transformer models and enable a more efficient design process for transformer models.\nEvaluating Transformer without Training  Recent studies [19  ###reference_b19###, 24  ###reference_b24###] have demonstrated that entropy, which captures the information capacity of neural network architecture, can be a reliable indicator for performance and generalization ability [19  ###reference_b19###, 24  ###reference_b24###] in convolutional neural networks.\nIn this part, we provide experimental results that empirically establish a strong correlation between our proposed entropy of untrained transformers and their final performance on the LM1B [36  ###reference_b36###] dataset after training.\nFigure 1  ###reference_### illustrates the correlation between the model performance (negative perplexity) and their corresponding entropy scores.\nResults indicate strong correlations, as evidenced by Spearman’s Rank Correlation () and Kendall Rank Correlation () scores exceeding 0.8 and 0.6, respectively.\nThis suggests that entropy can serve as a reliable training-free proxy for evaluating transformer architecture.\nFurthermore, we compare our entropy to DSS-Score [37  ###reference_b37###] used in Vision Transformers (ViTs) and decoder params [21  ###reference_b21###].\nAs depicted in Figure 1  ###reference_###, our proposed entropy outperforms the other two indicators.\n###figure_1###"
        },
        {
            "section_id": "3.1",
            "parent_section_id": "3",
            "section_name": "Preliminaries",
            "text": "Transformers have gained prominence due to their ability to model complex functions that involve long-range dependencies.\nDecoder-only, or autoregressive transformers, operate by predicting the next element in a sequence based on the preceding elements.\nA standard autoregressive transformer comprises an embedding layer to project sequences of tokens to hidden dimensions and stacks of transformer layers to capture long-term dependencies between input tokens using the self-attention mechanism.\nA transformer layer includes two main components: a multi-head attention (MHA) module and a position-wise feed-forward network (FFN).\nThe MHA module facilitates capturing contextual information by attending to different positions within the input sequence, while the FFN performs element-wise transformations to introduce non-linearity and improve representational capacity.\nMulti-head attention (MHA) is a crucial component within the transformer architecture that enables the model to selectively attend to different segments of the input sequence.\nThis mechanism involves projecting the input sequence into multiple attention heads, each of which calculates an independent attention distribution.\nIn MHA computation, there are specifically four main matrices involved: attention matrices  and output project matrix . Given the output of previous layers  as input, the attention function is formulated as:\nwhere , , and  represent queries, keys, and values, respectively.\nMHA is defined by concatenating  attention heads and producing outputs as follows:\nIn addition, the transformer layer adopts residual connection and layer normalization on top of MHA to compute the final outputs.\nIn addition to the MHA, each transformer layer includes a feed-forward network (FFN).\nThe FFN applies two point-wise fully connected layers followed by a non-linear activation function, such as ReLU. Operations within FFN can be formulated as follows:\nSimilarly, the FFN also incorporates residual connections and layer normalization to compute the final outputs:\nExpressiveness in Deep Network  From the perspective of information theory [19  ###reference_b19###  ###reference_b19###, 26  ###reference_b26###  ###reference_b26###], deep neural networks can be regarded as information systems, and their performance is closely related to the expressive power of such networks.\nThe notion of entropy is often used to measure such expressiveness through intermediate feature maps [25  ###reference_b25###  ###reference_b25###] in convolutional neural networks (CNNs).\nIn the case of transformers, we propose to define the entropy of transformers from the perspective of parameter subspaces.\nSuppose that  presents a linear mapping with  input channels and  output channels. The elements of  are randomly sampled from the standard Gaussian distribution . According to previous works [22  ###reference_b22###  ###reference_b22###], the subspace spanned by the random linear mapping  has\nwhere ,  is the -th largest singular value of \nand  is a small constant.\nFor an -layer network , we define the network entropy  by accumulating the entropy of matrices in each layer as the following:\nEffectiveness in Deep Network  The entropy measures the expressiveness of the deep neural network, which is positively correlated with the network performance [25  ###reference_b25###  ###reference_b25###].\nHowever, directly maximizing the above-defined entropy leads to the creation of over-deep networks, since according to Eq. (8  ###reference_###  ###reference_###), the expressivity (entropy) grows exponentially faster in depth (number of layers ), than in width (dimension of ).\nFor an over-deep network, a small perturbation in low-level layers of the network will lead to an exponentially large perturbation in the high-level output of the network [27  ###reference_b27###  ###reference_b27###].\nDuring the back-propagation process, the gradient flow often cannot effectively propagate through the entire network.\nThough recent works have attempted to alleviate the trainability issues by revising initialization strategies [28  ###reference_b28###  ###reference_b28###, 29  ###reference_b29###  ###reference_b29###], adding skip connections [30  ###reference_b30###  ###reference_b30###, 31  ###reference_b31###  ###reference_b31###], or proposing better architectures [32  ###reference_b32###  ###reference_b32###, 33  ###reference_b33###  ###reference_b33###], training over-deep networks still remains a rather challenging problem.\nTo verify the negative impact when the network is over-deep, in Table 1  ###reference_###  ###reference_###, we conduct experiments of training two transformer architectures with a similar parameter size of 40 M.\nOne model, referred to as the ‘Wide’ model, consists of only one layer and an embedding dimension of 256.\nThe other model, referred to as the ‘Deep’ model, consists of 24 layers but only with an embedding dimension of 64.\nBoth models are trained under the same setting until convergence. We observe that even though the ‘deep’ network has much higher entropy, it obtains worse perplexity performance after training than the ‘wide’ network.\nThis observation aligns with the common belief that over-deep networks hinder effective information propagation [27  ###reference_b27###  ###reference_b27###] and are difficult to train and optimize [34  ###reference_b34###  ###reference_b34###].\nTo address the potential trainability issues, we propose adding additional constraints to control the depth-width ratio of networks. Specifically, we adopt the term effectiveness  from the work [27  ###reference_b27###  ###reference_b27###] and define it as follows:\nHere,  is the effective width of a -layer network and  is a scaling factor to control  within the range of 0 and 1. To enforce the above constraint, we revise Eq. (8  ###reference_###  ###reference_###) as follows:\nCompared to the previous subspace entropy definition, Eq. (10  ###reference_###  ###reference_###) penalizes networks with larger depth-to-width ratios (higher ).\nThis constraint helps alleviate potential trainability issues by promoting a more balanced depth-width ratio in the network architecture.\nBy considering both expressiveness (entropy) and effectiveness (the depth-width ratio), we aim to design more capable and trainable models.\nEntropy of Transformers  Consider a -layer transformer model with embedding dimension  and FFN dimension , according to Theorem 1 in  [35  ###reference_b35###  ###reference_b35###], the depth-width sufficiency behavior satisfied a logarithmic condition in transformer models.\nSubsequently, we propose to define the effective width of MHA and FFN and their corresponding entropy as:\nIn practice, we find that using weighted entropy for MHA and FFN gives us a more reliable indicator for model performance. Therefore, we define the total entropy of the transformer model as linear combinations of the MHA and FFN entropy:\nwhere  are tunable hyperparameters.\nFast Entropy Approximation  Given the above definitions, we can easily calculate entropy for any transformer model.\nHowever, performing singular value decomposition (SVD) is a costly operation. For large models, it sometimes requires minutes to run SVD, which inhibits a zero-cost design.\nTo accelerate the entropy computation, we build an entropy lookup table to approximate the total entropy of a given transformer model.\nThe lookup table is built through a pre-computation process that considers all possible combinations of expected entropy values for different dimensions.\nThis step incurs only a one-time cost and the resulting lookup table can be shared across multiple experiments.\nWith the lookup table in place, we can efficiently calculate the entropy of transformer models and enable a more efficient design process for transformer models.\nEvaluating Transformer without Training  Recent studies [19  ###reference_b19###  ###reference_b19###, 24  ###reference_b24###  ###reference_b24###] have demonstrated that entropy, which captures the information capacity of neural network architecture, can be a reliable indicator for performance and generalization ability [19  ###reference_b19###  ###reference_b19###, 24  ###reference_b24###  ###reference_b24###] in convolutional neural networks.\nIn this part, we provide experimental results that empirically establish a strong correlation between our proposed entropy of untrained transformers and their final performance on the LM1B [36  ###reference_b36###  ###reference_b36###] dataset after training.\nFigure 1  ###reference_###  ###reference_### illustrates the correlation between the model performance (negative perplexity) and their corresponding entropy scores.\nResults indicate strong correlations, as evidenced by Spearman’s Rank Correlation () and Kendall Rank Correlation () scores exceeding 0.8 and 0.6, respectively.\nThis suggests that entropy can serve as a reliable training-free proxy for evaluating transformer architecture.\nFurthermore, we compare our entropy to DSS-Score [37  ###reference_b37###  ###reference_b37###] used in Vision Transformers (ViTs) and decoder params [21  ###reference_b21###  ###reference_b21###].\nAs depicted in Figure 1  ###reference_###  ###reference_###, our proposed entropy outperforms the other two indicators.\n###figure_2###"
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "Designing Mobile Language Models",
            "text": "Search Space  In the design of MeRino, we introduce an adaptive block-wise search space to construct the backbone architecture.\nThis allows us to determine the architectural parameters on a per-block basis.\nEach transformer block consists of numerous transformer layers of the same number of attention heads, hidden dimensions, and embedding dimensions.\nWithin each transformer block, in MHA layers, we fix the head dimension and make the attention head number elastic so that each attention module can decide its necessary number of heads.\nWe also set the Q-K-V dimensions the same as embedding dimensions; in FFN layers, the hidden dimension is decided by choosing the FFN ratio to the embedding dimension.\n###figure_3### To prevent information bottlenecks, we also ensure\nthat as the network goes deeper, the embedding dimension of each transformer block should be non-decreasing.\nMoreover, we incorporate parameter sharing technique [38  ###reference_b38###] within each transformer block.\nThis means that all MHA and FFN layers within the block share the same weights, resulting in transformer models of reduced memory footprint.\nIllustration can be found in Figure 2  ###reference_###. Details of our search space configuration are provided in Appendix A  ###reference_###.\nSearch Process  To design a transformer model  with  transformer blocks under a given computation budget , we propose to optimize the parameters  by solving a mathematical programming (MP) problem.\nThe objective of the MP problem is to maximize a weighted sum of entropy, representing the expressiveness and effectiveness of the model, while considering constraints on the computational cost. The MP problem is formulated as follows:\nwhere , , and  denote the embedding dimension, FFN ratio, and number of layers in the -th transformer block, respectively.\nTo solve this optimization problem, we employ an Evolutionary Algorithm [39  ###reference_b39###].\nNote that Eq. (15  ###reference_###) can be solved by any non-linear programming solver in principle. We choose EA due to its simplicity.\nWe first construct the initial population by randomly generating  architectures with parent size . At each iteration , we randomly select an architecture from  and mutate it.\nThe embedding dimension of the selected block is mutated in a given range, which has to be no bigger than the next block and no smaller than the previous block.\nThe mutated architecture  is added to the population if it meets the budget constraints .\nFinally, we maintain the population size by removing networks with bottom  entropy.\nAfter  iterations, the architecture with the highest entropy score is returned as the output network.\nSince our formulated problem is purely mathematical, it can be solved nearly instantly on the CPU. A detailed description of EA and the mutation algorithm is given in Appendix B  ###reference_###."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Experiments",
            "text": "In this section, we first describe experimental settings for search, training, and evaluation. Next, we report the results of MeRino on various NLP tasks and compare our approach with existing pretrained LLMs. Finally, we conduct ablation studies of different key components in MeRino."
        },
        {
            "section_id": "4.1",
            "parent_section_id": "4",
            "section_name": "Experimental Settings",
            "text": "Search Settings  In searching for MeRino, the number of iterations  is set to 100000, with a population size  of 512 and the parent size  of 64. We conduct searches for three different FLOP targets (60/110/160 G). We limit the number of transformer blocks to  and set  and .\nTraining Settings  We mostly follow settings in [6  ###reference_b6###] and  [40  ###reference_b40###] and pre-train our models on the Pile dataset [41  ###reference_b41###] for 600k steps ( 300B tokens) with an effective batch size of 512 using AdamW optimizer [42  ###reference_b42###], with a starting learning rate of 6e-4 and warm-up steps of 1000, and linear learning rate decay schedule. We also enable automatic mixed precision (AMP) for better training efficiency.\nEvaluation Settings  We evaluate our models for zero-shot natural language inference tasks across nine different downstream NLP tasks, namely HellaSwag [43  ###reference_b43###], WinoGrande [44  ###reference_b44###], OpenBookQA [45  ###reference_b45###], PubmedQA [46  ###reference_b46###], LogiQA [47  ###reference_b47###], and SuperGLUE [48  ###reference_b48###] benchmark BoolQ, CB, WIC and RTE. FLOPs are calculated with a batch size of 1 and sequence length of 1024 and inference throughput is measured at token per second on NVIDIA Jetson Nano 8GB."
        },
        {
            "section_id": "4.2",
            "parent_section_id": "4",
            "section_name": "Results",
            "text": "Since our scope is mobile-friendly language models, we mainly compare pretrained LLMs that can be run on NVIDIA Jetson Nano 8GB with out-of-memory (OOM) issues.\nWe compare the average accuracy of our MeRino models with baseline models, such as GPT-2 [4  ###reference_b4###], OPT [6  ###reference_b6###], Pythia [40  ###reference_b40###] and Cerebras-GPT [49  ###reference_b49###].\nTable  2  ###reference_### reports the comparisons of MeRino and current state-of-the-art autoregressive transformer-based language models.\nCompared to the OPT family, MeRino achieves superior accuracy with much less parameter size and FLOPs.\nSpecifically, MeRino-64M is 0.4% better than OPT-350M with 82% and 78% reduction in model size and computation respectively.\nAbove all, MeRino achieves an average speedup of 2.0 and 7.3 against OPT-125M and OPT-350M, respectively.\nWhen compared to open-sourced LLMs that are trained on the Pile dataset, MeRino-64M achieves 0.3% higher average zero-shot accuracy than Cerebras-GPT while reducing parameter size and FLOPs by 1.7 and 1.6, respectively; MeRino-61M is also 0.6% more accurate than GPT-2 with 3.3 lower latency; our smallest model, MeRino-52M is able to outperform Pythia-70M by 0.5% with 1.9 faster runtime."
        },
        {
            "section_id": "4.3",
            "parent_section_id": "4",
            "section_name": "Ablation Studies",
            "text": "Impact of  and   As shown in Table 3  ###reference_###, effectiveness constraint  plays a key role in helping our entropy-driven framework design more capable and trainable models.\nWhen using effectiveness constraint , the final searched language model obtains +2.4% average accuracy gain.\nIn terms of correlation experiments on the LM1B dataset shown in Figure 1  ###reference_###, entropy with effectiveness constraint  can provide a more reliable prediction of the final perplexity performance of trained transformer models, especially in identifying high-performance architectures.\nWe also study the impact of weight  on our entropy-driven approach. As shown in Figure 3  ###reference_###, naively adding MHA and FFN without weights cannot represent the perplexity performance very well.\nWeighted entropy, on the other hand, especially when properly tuned, exhibits much better correlation results than unweighted entropy.\nIn Table 3  ###reference_###, we further evaluate the impact of weighted entropy on downstream performance. We can see that using weighted entropy helps improve the average zero-shot accuracy by 0.8%.\n###table_1### ###figure_4### Parameter Sharing  We report the effect of parameter technique on MeRino in Table 4  ###reference_### for three different FLOPs targets (60/110/160 G).\nWe can see that sharing parameters within the same transformer block helps improve parameter efficiency and reduce the model size while having a negligible impact on both the language modeling (see Pile test loss) and downstream zero-shot performance."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Limitations",
            "text": "As no research is MeRino, MeRino has several limitations as well. First, the design of MeRino explores entropy only from parameter subspace due to its straightforwardness.\nFurther exploration of entropy in the feature space could provide a better theoretical understanding of transformer architecture and potentially lead to improved model designs.\nSecond, our design only focuses on the ”macro-structure” of the LLMs (channels/depths/heads).\nOther key components, such as residual connections, layer normalization, and nonlinear activations, are also essential to achieve good performance.\nHowever, the theoretical foundation for these components is not well-studied, especially from an information theory perspective.\nHow to integrate these components in our entropy-based framework remains an open question and we would leave it for our future research."
        },
        {
            "section_id": "6",
            "parent_section_id": null,
            "section_name": "Conclusion",
            "text": "In this paper, we present MeRino, a novel design framework aiming to generate efficient autoregressive language models for IoT devices, such as NVIDIA Jetson Nano.\nBy modeling transformer models as information processing systems, MeRino leverages the Maximum Entropy Principle and optimizes the network architecture by maximizing the subspace entropy of transformer decoders and model trainability under given computational budgets.\nWe show that MeRino can achieve comparable performance against state-of-the-art LLMs with significant improvement in model size reduction and inference runtime speedup on resource-constrained devices."
        }
    ]
}