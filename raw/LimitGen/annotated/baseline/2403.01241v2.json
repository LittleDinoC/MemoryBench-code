{
    "title": "IntactKV: Improving Large Language Model Quantization by Keeping Pivot Tokens Intact",
    "abstract": "Large language models (LLMs) excel in natural language processing but demand intensive computation. To mitigate this, various quantization methods have been explored, yet they compromise LLM performance. This paper unveils a previously overlooked type of outliers in LLMs. Such outliers are found to allocate most of the attention scores on initial tokens of input, termed as pivot tokens, which are crucial to the performance of quantized LLMs. Given that, we propose IntactKV to generate the KV cache of pivot tokens losslessly from the full-precision model. The approach is simple and easy to combine with existing quantization solutions with no extra inference overhead. Besides, IntactKV can be calibrated as additional LLM parameters to boost the quantized LLMs further with minimal training costs. Mathematical analysis also proves that IntactKV effectively reduces the upper bound of quantization error. Empirical results show that IntactKV brings consistent improvement across different LLMs and downstream tasks, leading to the new state-of-the-art for LLM quantization. The codes are available at https://github.com/ruikangliu/IntactKV.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "Large language models (LLMs) have achieved remarkable progress in various tasks and benchmarks in natural language processing. Nonetheless, the rise of LLMs also increases computational intensity and memory requirements. This motivates various research to decrease the inference cost of LLMs, e.g., quantization, pruning, and speculative decoding. Among these methods, network quantization converts the network parameters or activations from floating-point to fixed-point formats, which is a popular technique to reduce the model size and computational resources. Nevertheless, quantization inevitably affects the performance of LLMs. The leading cause comes from the outliers in LLM activations, which are sensitive to network quantization. There are efforts to either use mixed-precision formats or re-scale network weights of the outlier channels. These methods are built on the premise that outliers persist in fixed channels across all tokens. However, we find this is not the case for all outliers in LLMs.\n\nIn this paper, we discover a new type of outlier that is overlooked by previous quantization methods. These outliers exhibit extremely high values at only the [BOS] and some other common tokens (e.g., “,” and “.”) at the beginning of the input, referred to as pivot tokens. We find the extreme values of these outliers make the self-attention concentrate on the pivot tokens, leaving the rest of the tokens untouched. This is also known as attention sinks, which is critical to the model performance. The effect of quantization on these pivot tokens should be carefully studied to improve the quantized LLMs.\n\nTowards that end, we are motivated to propose IntactKV, a simple strategy that is orthogonal to most existing quantization solutions. The key idea behind IntactKV is to generate the lossless KV cache of pivot tokens from the full-precision model. By keeping the KV cache of pivot tokens intact, quantization error accumulated on the output of self-attention will be effectively alleviated in the rest of the decoding steps. The integration of IntactKV comes with no additional inference overhead.\n\nMoreover, IntactKV can also serve as extra trainable parameters in addition to the LLM backbone. The calibration process of IntactKV follows the convention of PTQ, which further decreases the quantization error. To get more insights from IntactKV, we also provide mathematical analysis and the results show that IntactKV can effectively lower the upper bound of quantization error.\n\nEmpirical results show that IntactKV consistently improves the capability of different quantization methods on various open-sourced LLMs across different tasks and benchmarks such as PPL, MMLU, commonsense QA, and MT-bench, achieving new state-of-the-art results for weight-only quantization as well as weight and activation quantization, e.g., lossless INT4 weight-only quantization for Vicuna-v1.3-13B on commonsense QA tasks. Moreover, calibrating IntactKV with INT4 quantization even matches the full-precision model on aligning with human preferences, as evaluated by GPT-4 on MT-bench."
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Motivation",
            "text": "Different from the outliers that persist in several fixed channels across different tokens (Dettmers et al., 2022; Xiao et al., 2023; Lin et al., 2023), we find a new variant of outlier that is specific to some initial tokens of the input sequence. By visualizing the activation of Transformer layer output in Figure 1(a) and Figure 1(b), there exist peaks with magnitudes over 1e3. These outliers can be hundreds of times larger than the previous outliers that persist in fixed channels across all tokens, as enlarged in Figure 1(a) and Figure 1(b). More visualizations can be found in Appendix C. It is found that such huge outliers usually occur at the [BOS] token and some other uninformative initial tokens (e.g., \".\" or \",\") at particular channels, regardless of the rest of the input sequence. We thus name these tokens pivot tokens given their dominating values in the activation. Recently, a concurrent work (Sun et al., 2024) also discovers such outliers with more detailed studies. We hypothesize that the outliers over these pivot tokens may propagate to queries and keys in the self-attention. Consequently, the attention scores will be concentrated on these pivot tokens than the rest ones, a.k.a attention sinks Xiao et al. (2024). To verify the hypothesis, we plot the attention scores in Figure 1(c) and Figure 1(d). It can be found that the pivot tokens indeed dominate the attention scores, especially for the first token (i.e., [BOS]). This corresponds to the observations in attention sinks (Xiao et al., 2024), which are empirically verified to be critical to the model performance. The recent study by (Bondarenko et al., 2023) also shows that concentrating on these tokens naturally helps the attention head do nothing but simply a partial update of the residual. In the decoding stage of LLMs, all generated tokens need to interact with pivot tokens through self-attention. However, as mentioned in Section 2.1, network quantization would inevitably distort the output from the full-precision model. The concentrated scores of pivot tokens thus can be further deviated by quantization, which downgrades the model performance."
        },
        {
            "section_id": "2.1",
            "parent_section_id": "2",
            "section_name": "Preliminaries on LLM Quantization",
            "text": "Network quantization is popularly studied in the literature of efficient LLMs Frantar et al. (2022  ###reference_b14###); Lin et al. (2023  ###reference_b20###); Shao et al. (2024  ###reference_b29###). It allows larger throughput by reducing the model size and leads to practical inference speedup. Given the full-precision weight, quantization aims to convert it to the low-bit representation. The general -bit uniform quantization can be represented as where is the quantization step size, and is the projection function onto the set of -bit integers. While we mainly focus on weight-only quantization, Equation 1  ###reference_### can be similarly used to quantize activations and KV cache of LLMs to increase the inference throughput Xiao et al. (2023  ###reference_b35###); Shao et al. (2024  ###reference_b29###); Hooper et al. (2024  ###reference_b17###). Following most existing works in LLM quantization, we focus on post-training quantization (PTQ) Frantar et al. (2022  ###reference_b14###); Lin et al. (2023  ###reference_b20###), since it does not introduce extra training overhead as those in quantization-aware training (QAT) Liu et al. (2023a  ###reference_b21###); Li et al. (2024  ###reference_b19###). Quantization inevitably downgrades LLMs in low-bit settings, where the outliers in quantized LLMs are found to be the cause of the deterioration Dettmers et al. (2022  ###reference_b12###). In the next, we study the details of how these outliers affect the LLM quantization."
        },
        {
            "section_id": "2.2",
            "parent_section_id": "2",
            "section_name": "Revisiting Outliers in LLMs",
            "text": "We discover a new type of outlier that is specific to particular tokens, which leads to significant changes in the performance of large language models (LLMs). Unlike the outliers that persist across different tokens in fixed channels, we identify a new variant that occurs with some initial tokens of the input sequence. Visualizations of Transformer layer output in Figure 1(a) and Figure 1(b) show peaks exceeding 1e3 in magnitude. These outliers are considerably larger than prior outliers, occurring at the beginning of sequences with tokens such as [BOS] and certain punctuation marks in specific channels. We refer to these as pivot tokens due to their dominant activation values. Concurrent research also identifies such outliers with detailed analysis.\n\nWe hypothesize that these outliers may influence queries and keys in self-attention, causing attention scores to focus on pivot tokens. This is confirmed by attention score plots in Figure 1(c) and Figure 1(d), showing the dominance of pivot tokens, especially the first token [BOS]. Other studies have shown that focusing on these tokens can lead to attention heads taking minimal action, performing partial updates of the residuals.\n\nDuring the decoding stage of LLMs, all generated tokens interact with pivot tokens via self-attention. However, network quantization can distort this interaction compared to a full-precision model, potentially degrading performance by altering the focused scores on pivot tokens."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "Method",
            "text": "In this section, we introduce IntactKV, a simple and easy-to-implement method to improve the quantized LLMs. The key idea behind this is to keep the KV cache of the pivot tokens intact, i.e., without any distortion raised by quantization. An overview of our method can be found in Figure 3.\n\nIt is important to choose the pivot tokens and the associated IntactKV carefully. Given the observations in Figure 2, one might consider picking pivot tokens with the most MSE reduction for IntactKV; however, IntactKV acts as the prefix to the KV cache of quantized LLMs, and it must start from the first token and be consecutive in length. This ensures it is input agnostic, and the full-precision LLMs can be safely discarded once IntactKV is generated.\n\nNext, we provide practical solutions to this problem for different LLMs. For pre-trained LLMs, we propose the IntactKV of size one that only contains [BOS] KV cache. It is a convention to prepend [BOS] to the input of pre-trained LLMs. Moreover, as illustrated in Section 2, [BOS] is the pivot token with extreme outlier and attention scores. The KV cache of [BOS] has a significant impact on the MSE of the quantized model. Employing a lossless [BOS] KV cache is thus believed to decrease the quantization loss.\n\nFor supervised fine-tuned (SFT) models, when the input follows the system prompt, we argue that extending IntactKV to the same length of the system prompt can further improve quantized LLMs. In addition to [BOS], other tokens appearing at the beginning of the input sequence also have the potential to serve as pivot tokens (see Figure 1).\n\nThe system prompt is usually prepended to the input, allowing it to cover more pivot tokens. Remedying the quantization error of these pivot tokens’ KV cache can be helpful to compensate for the quantization error. We find that for Vicuna models, the system prompt is sufficient to cover all the pivot tokens, with more details provided in Appendix C.3.\n\nFinally, we highlight that IntactKV does not introduce extra latency overhead during inference. As IntactKV is pre-computed, the pre-filling stage of the quantized LLMs can be accelerated as well. The memory overhead to save IntactKV is negligible compared with the LLM backbone. For instance, there are only 34 tokens of the system prompt for Vicuna-v1.5-7B, and thus IntactKV takes only 0.13% of the LLM model parameters."
        },
        {
            "section_id": "3.1",
            "parent_section_id": "3",
            "section_name": "Preserving the KV Cache of Pivot Tokens",
            "text": "According to Section 2.2, the attention sinks of pivot tokens are likely to deteriorate by quantization. To alleviate this issue, we propose IntactKV, a simple yet effective strategy to keep these pivot tokens intact. Specifically, as illustrated in Figure 3(a), we leverage the full-precision LLM to generate the lossless KV cache of pivot tokens, which is saved offline. The quantized LLM then loads IntactKV as the prefix to concatenate with the rest of the KV cache and continues with the regular auto-regressive decoding process. The pseudo code of the inference scheme with IntactKV is presented in Figure 3(b).\n\nIn order to study the benefits of IntactKV, we conduct a preliminary test on the mean squared error (MSE) of the attention and transformer layer output. From Figure 2, it is natural that the increasing size of IntactKV gives the monotonically decreasing MSE on both the attention and transformer layers. More importantly, it is found the pivot tokens observed in Section 2.2 (e.g., [BOS] and other delimiter tokens) give the most significant decrease on the MSE, which demonstrates the importance of their KV cache. This aligns with the observations in Figure 1 that pivot tokens exhibit outliers with extreme values and attention sinks.\n\nIt is the key design to choose the pivot tokens and the associated IntactKV. Given the observations in Figure 2, one can naively pick pivot tokens with the most MSE reduction for IntactKV. However, this is in fact not the case. Since IntactKV acts as the prefix to the KV cache of quantized LLMs, it must start from the very first token, and be consecutive in length. This ensures it to be input agnostic, and the full-precision LLMs can be safely discarded once IntactKV is generated.\n\nNext, we provide practical solutions to this problem for different LLMs. For pre-trained LLMs, we propose the IntactKV of size one that only contains [BOS] KV cache. It is a convention to prepend [BOS] to the input of pre-trained LLMs. Moreover, as illustrated in Section 2, [BOS] is the pivot token with extreme outlier and attention scores. Besides, the KV cache of [BOS] has a great impact on the MSE of the quantized model. Employing a lossless [BOS] KV cache is thus believed to decrease the quantization loss.\n\nFor supervised fine-tuned (SFT) models, when the input follows the system prompt, we argue that extending IntactKV to the same length of the system prompt can further improve quantized LLMs. In addition to [BOS], other tokens appearing at the beginning of the input sequence also have the potential to serve as pivot tokens (see Figure 1). The system prompt is usually prepended to the input, which allows it to cover more pivot tokens. As shown in Figure 2, remedying the quantization error of these pivot tokens’ KV cache can be helpful to compensate for the quantization error. We find that for Vicuna models, system prompt is enough to cover all the pivot tokens, more details can be found in Appendix C.3.\n\nFinally, we highlight that IntactKV does not introduce extra latency overhead during inference. Besides, as IntactKV is pre-computed, the pre-filling stage of the quantized LLMs can be accelerated as well. The memory overhead to save IntactKV is also negligible compared with the LLM backbone. For instance, there are only 34 tokens of the system prompt for Vicuna-v1.5-7B, and thus IntactKV takes only 0.13% of the LLM model parameters."
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "IntactKV as Trainable Parameters",
            "text": "Since IntactKV is pre-computed and saved offline, it can be treated as extra trainable parameters aside from the LLM backbone to further boost the quantized LLMs. Despite there being no information loss at the pivot tokens, the quantization may still introduce errors to the KV cache during the decoding stage. As shown in Figure 3(a), we calibrate IntactKV to compensate for the quantization error accumulated in the following tokens.\n\nWhile there are various metrics to characterize the quantization discrepancy, we adopt the mean squared error of the transformer layer output between the full-precision LLM and quantized LLM, a simple yet most widely used metric, i.e.,\n\n![equation](https://latex.codecogs.com/svg.latex?MSE(\\Theta_{IntactKV})%20=%20\\frac{1}{L}\\sum_{l=1}^{L}||m_l(x;\\theta_l^f)%20-%20m_l(x;\\theta_l^q)||^2)\n\nwhere \\(\\Theta_{IntactKV}\\) denotes the set of IntactKV, \\(m_l\\) is the mapping function for the \\(l\\)-th Transformer layer, and \\(L\\) is the number of Transformer layers in LLM. \\(x\\) is the input sequence, while \\(\\theta_l^f\\) and \\(\\theta_l^q\\) are full-precision and quantized weights respectively. Note that the full-precision model is only required during the calibration process, and it can be safely discarded afterward. \n\nIt is empirically found that calibration of system prompt IntactKV in SFT models generally gives more improvement than the calibration of [BOS] IntactKV in pre-trained LLMs. This matches the intuition that a larger size of IntactKV increases the potential to compensate for quantization errors. \n\nAs we focus on post-training quantization, the training of IntactKV is highly lightweight since the only learnable parameters introduced are IntactKV, i.e., the KV cache of pivot tokens. It takes only as few as 20 epochs on a calibration set with 128 samples. Besides, training with a quantized model further lowers the memory cost. The calibration process takes about only 10 minutes for a 7B model and less than 20 minutes for a 13B model on one computing device."
        },
        {
            "section_id": "3.3",
            "parent_section_id": "3",
            "section_name": "Theoretical Analysis",
            "text": "In this section, we provide a theoretical view of how the proposed IntactKV benefits the quantized LLM. For the clarity of presentation, our analysis is built on the self-attention module of a Transformer layer, while it can be readily extended to the FFN module and multiple layers.\n\nSpecifically, we denote  as the KV cache during the decoding stage, and  is the query vector, where  and  are the sequence length and head dimension. Recall that the output of each attention head  is computed as  where  is the weight matrix of the projection layer. By quantizing the LLMs, there will be errors accumulated on the KV cache, denoted as .\n\nTherefore, we are interested in showing how  and  are propagated to the change of attention head , and to what extent IntactKV alleviates the distortion. Given the query vector  and the change of KV caches , the change of the attention head  is bounded by  where  and .\n\nThe proof to Theorem 1  ###reference_orem1### can be found in Appendix IntactKV: Improving Large Language Model Quantization by Keeping Pivot Tokens Intact. We preserve the terms with respect to  and  of interests, and leave the rest as constants.\n\nNote that  can be further separated by the pivot tokens  and rest tokens , and similar notations hold for . Therefore, we have  and .\n\nWith IntactKV, we have  since they are generated losslessly, which decreases the upper bound of . Moreover, it can further reduce the bound by incorporating more pivot tokens. This also aligns with the observation in Figure 2  ###reference_### that a larger size of IntactKV gives a lower MSE of the attention module."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Experiments",
            "text": "We evaluate the proposed IntactKV on various sizes of open-sourced LLMs, including LLaMA (Touvron et al., 2023a) (7B-65B), LLaMA-2 (Touvron et al., 2023b) (7B-70B), Vicuna-v1.3 (Chiang et al., 2023) (7B-33B) and Vicuna-v1.5 (7B-13B). We denote models that keep intact [BOS] KV as IntactKV, and models that keep intact system prompt KV as IntactKV.\n\nWe mainly consider weight-only quantization methods, including AWQ (Lin et al., 2023). For AWQ, we use the official code or checkpoint with Pile (Gao et al., 2020) and WikiText2 (Merity et al., 2016) calibration set, following existing methods. More implementation details can be found in Appendix E. We adopt asymmetric group-wise quantization with a group size of 128 and mainly focus on INT3 and INT4 quantization since INT8 is empirically lossless on various task metrics (Dettmers et al., 2022).\n\nOur IntactKV can be readily combined with these existing weight-only quantization methods, and the experiment results are shown in Section 4.2. Moreover, aside from weight-only quantization, the proposed IntactKV can be similarly applied for KV cache quantization and extended to activation quantization, as detailed in Section 4.3 and Section 4.4. It is worth noting that the integration of IntactKV with weight-only/KV cache/activation quantization comes with no extra inference cost and works as an effective plugin to effectively boost the accuracy of quantized models.\n\nFor pre-trained LLMs (i.e., LLaMA and LLaMA-2), we report the perplexity (PPL) of language generation on C4 (Raffel et al., 2020) and WikiText2 (Merity et al., 2016) dataset. For SFT models (i.e., Vicuna-v1.3 and v1.5), we conduct evaluation over a wide range of downstream tasks. We test the zero and five-shot performance on the Massively Multitask Language Understanding (MMLU) (Hendrycks et al., 2020) benchmark. Meanwhile, we also evaluate seven zero-shot commonsense QA tasks: OBQA (Mihaylov et al., 2018), WinoGrande (Sakaguchi et al., 2021), ARC-Challenge, ARC-Easy (Clark et al., 2018), BoolQ (Clark et al., 2019), HellaSwag (Zellers et al., 2019), and LAMBADA (Paperno et al., 2016). Additionally, we evaluate quantized Vicuna on MT-bench (Zheng et al., 2023), a high-quality dataset consisting of 80 open-ended multi-turn questions, to gauge their alignment with human preferences. The responses generated by quantized models are judged by GPT-4 with a total score of 10. More evaluation details can be found in Appendix F.\n\nFor evaluation on PPL, MMLU, and commonsense QA tasks, we adopt IntactKV that only includes [BOS] KV since the input sequence of these tasks does not use any system prompt. For evaluation of SFT models on MT-bench, we adopt IntactKV to keep an intact system prompt KV cache. The system prompt of Vicuna can be found in Appendix B.\n\nFor training the cached IntactKV, we randomly sample 128 samples from ShareGPT111 dataset as our calibration dataset, consisting of multi-turn ChatGPT (OpenAI, 2022) conversations. The layer-wise MSE loss defined in Equation 2 is calculated on the response of ChatGPT. We use AdamW optimizer with learning rate, training for 160 optimizer update steps with a gradient accumulation step of 16, i.e., 20 epochs.\n\nAs mentioned in Section 3.2, training IntactKV leads to comparable performance compared with vanilla IntactKV. Instead, the calibration of IntactKV has more potential to improve quantized LLMs with longer system prompt. Thus, we primarily evaluate the IntactKV with the KV cache of the system prompt as trainable parameters in the following experiments. For weight and activation quantization, we further quantize IntactKV to lower bits to avoid extra inference overhead, which only incurs negligible accuracy loss. More details of activation quantization can be found in Section 4.4.\n\nWe implement IntactKV on the quantized Vicuna models and evaluate the multi-task problem-solving ability on the MMLU benchmark. Table 3 presents the detailed zero"
        },
        {
            "section_id": "4.1",
            "parent_section_id": "4",
            "section_name": "Settings",
            "text": "We evaluate the proposed IntactKV on various sizes of open-sourced LLMs, including LLaMA (7B-65B), LLaMA-2 (7B-70B), Vicuna-v1.3 (7B-33B) and Vicuna-v1.5 (7B-13B). We denote models that keep intact [BOS] KV as IntactKV, and models that keep intact system prompt KV as IntactKV.\n\nOur IntactKV can be readily combined with existing weight-only quantization methods. Moreover, aside from weight-only quantization, the proposed IntactKV can be similarly applied for KV cache quantization and extended to activation quantization. It is worth noting that the integration of IntactKV with weight-only/KV cache/activation quantization comes with no extra inference cost and works as an effective plugin to effectively boost the accuracy of quantized models.\n\nFor pre-trained LLMs (i.e., LLaMA and LLaMA-2), we report the perplexity (PPL) of language generation on C4 and WikiText2 dataset. For SFT models (i.e., Vicuna-v1.3 and v1.5), we conduct evaluation over a wide range of downstream tasks. We test the zero and five-shot performance on the Massively Multitask Language Understanding (MMLU) benchmark. Meanwhile, we also evaluate seven zero-shot commonsense QA tasks: OBQA, WinoGrande, ARC-Challenge, ARC-Easy, BoolQ, HellaSwag, and LAMBADA. Additionally, we evaluate quantized Vicuna on MT-bench, a high-quality dataset consisting of 80 open-ended multi-turn questions, to gauge their alignment with human preferences. The responses generated by quantized models are judged by GPT-4 with a total score of 10.\n\nFor evaluation on PPL, MMLU, and commonsense QA tasks, we adopt IntactKV that only includes [BOS] KV since the input sequence of these tasks does not use any system prompt. For evaluation of SFT models on MT-bench, we adopt IntactKV to keep an intact system prompt KV cache.\n\nFor training the cached IntactKV, we randomly sample 128 samples from the ShareGPT dataset as our calibration dataset, consisting of multi-turn ChatGPT conversations. The layer-wise MSE loss is calculated on the response of ChatGPT. We use the AdamW optimizer with learning rate, training for 160 optimizer update steps with a gradient accumulation step of 16, i.e., 20 epochs. As mentioned, training IntactKV leads to comparable performance compared with vanilla IntactKV. Instead, the calibration of IntactKV has more potential to improve quantized LLMs with longer system prompt. Thus, we primarily evaluate the IntactKV with KV cache of system prompt as trainable parameters in the following experiments.\n\nFor weight and activation quantization, we further quantize IntactKV to lower bits to avoid extra inference overhead, which only incurs negligible accuracy loss."
        },
        {
            "section_id": "4.2",
            "parent_section_id": "4",
            "section_name": "Main Results",
            "text": "We first integrate our proposed IntactKV with AWQ on LLaMA and LLaMA-2 models. The effect of this integration on model accuracy is measured by the perplexity (PPL) metric, with results on the C4 dataset detailed in Table 1, and results on the WikiText2 dataset in Table 7. As indicated in these tables, IntactKV notably enhances the generative capabilities of quantized models across various LLMs and quantization methods, with AWQ+IntactKV consistently achieving new state-of-the-art (SOTA) results. These findings demonstrate the efficacy of IntactKV in improving quantized LLMs and particularly highlight the effectiveness of utilizing the lossless KV cache from full-precision models. We provide more experiment results on LLaMA-3 and other heterogeneous LLMs (e.g. OPT) in Appendix G.1. IntactKV significantly improves different quantized LLMs, especially for LLaMA-3 models with larger quantization error. These results further prove the compatibility of our IntactKV with various LLM backbones.\n\nFor SFT models, we implement IntactKV on the quantized Vicuna models and evaluate the multi-task problem-solving ability on the MMLU benchmark. Table 3 presents the detailed zero-shot and five-shot results for Vicuna-v1.3-13B. The results demonstrate that IntactKV significantly enhances the performance of quantized models across all categories of tasks and various quantization methods for Vicuna-v1.3-13B. Moreover, performance of Vicuna family under the five-shot setting is outlined in Table 2. Remarkably, IntactKV achieves an average improvement of 0.8% over AWQ across five model sizes, with AWQ+IntactKV exhibiting superior performance over all the other quantized models. More results on MMLU are provided in Appendix G.2.\n\nWe further evaluate the quantized Vicuna models on zero-shot commonsense QA tasks. The results of Vicuna-v1.3-13B, as detailed in Table 4, indicate that IntactKV enables significant improvements over various quantization methods. For example, AWQ+IntactKV surpasses the average accuracy of AWQ by 0.46% under INT3-g128 quantization. Additionally, Table 2 presents the average accuracy for various sizes of Vicuna models. In these evaluations, our IntactKV leads to an average accuracy improvement of 0.45% across different LLMs and quantization methods, which strongly demonstrates the efficacy of our proposed IntactKV. More results on commonsense QA tasks can be found in Appendix G.3.\n\nTo evaluate the quantized models’ generation capabilities in multi-turn conversations and their alignment with human preferences, we use GPT-4 to score the responses of quantized models on MT-Bench. We also calibrate IntactKV, denoted as IntactKV+Cal. From Table 5, IntactKV significantly boosts the quantized model and IntactKV+Cal further enhances generation quality by compensating for the quantization error. For example, the 3-bit Vicuna-v1.5-13B quantized by AWQ has been improved from 5.17 to 5.34 by using the IntactKV, which can be further boosted to 5.44 with trainable IntactKV. We provide INT4 quantization results in Table 13. Remarkably, with trainable IntactKV, AWQ+IntactKV even matches the full-precision model under INT4 quantization, while all other methods clearly lag behind the full-precision model. These results demonstrate the effectiveness of IntactKV as well as treating IntactKV as trainable parameters. Notably, the training process for the 7B model takes only 10 minutes on a single computing device, which is quite lightweight. In Appendix H, we further demonstrate the effectiveness of calibrating IntactKV by comparing it with group bias tuning, a commonly used fine-tuning strategy for quantized models. IntactKV calibration can achieve better or comparable results with group bias tuning while using significantly fewer trainable parameters. Besides, IntactKV calibration serves as a more versatile calibration strategy for quantized models, which is suitable for various quantization settings."
        },
        {
            "section_id": "4.3",
            "parent_section_id": "4",
            "section_name": "Extension to KV Cache Quantization",
            "text": "IntactKV can be readily applied to KV cache quantization to further decrease memory requirements. We employ a mixed-precision strategy that keeps IntactKV in FP16 while the rest of the KV cache is quantized to lower bits. This induces negligible memory overhead since IntactKV only contains the KV cache of the first few tokens. Furthermore, there are no additional inference costs since, in the workflow of KV cache quantization, all quantized KV cache needs to be de-quantized back to FP16 before the matrix multiplication. Keeping IntactKV in FP16 reduces the overhead of de-quantization, meaning we only need to concatenate the FP16 IntactKV with the de-quantized KV cache.\n\nFrom the observations, IntactKV notably improves AWQ across different models and KV cache bit widths under the INT3 weight quantization. For INT4 weight quantization, AWQ+IntactKV gains an average accuracy increase of 0.27% over the original quantized model. Additionally, quantizing the KV cache to INT8 leads to almost no performance drop on the MMLU benchmark. When equipped with IntactKV, the INT8 KV cache can surpass vanilla AWQ-quantized models with FP16 KV cache, especially under INT3 weight quantization."
        },
        {
            "section_id": "4.4",
            "parent_section_id": "4",
            "section_name": "Extension to Activation Quantization",
            "text": "In Table 6, we provide experiment results of combining IntactKV with QuaRot Ashkboos et al. (2024) for weight and activation quantization. The implementation details can be found in Appendix E. To avoid extra inference costs, we need to quantize the whole KV cache to lower bits and cannot keep the KV cache of pivot tokens intact. However, as detailed in Appendix I, we find that IntactKV has a significantly smoother distribution compared with the rest of the KV cache. Therefore, the full-precision IntactKV can be readily quantized to lower bits with negligible accuracy loss, thus rendering IntactKV amenable to weight and activation quantization with no extra inference costs. As shown in Table 6, our IntactKV significantly surpasses the performance of original quantized models for the quantization method, improving the PPL by 0.31 for QuaRot on average. When combined with QuaRot, our IntactKV achieves new state-of-the-art (SOTA) results on INT4 weight and activation quantization."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Conclusions",
            "text": "In this paper, we propose IntactKV, a simple and easy-to-combine method to improve large language model quantization. The research is motivated by the previously overlooked outliers over pivot tokens, which lead to attention sinks that are critical to the performance of quantized LLMs. By generating IntactKV with the full-precision model, the quantization error accumulated over the attention scores can be effectively alleviated. IntactKV can also be calibrated as additional parameters to the LLM backbone, further improving the quantized LLMs. Experiments show that combining the proposed IntactKV gives consistent improvement on various sizes of LLMs and across multiple downstream tasks, leading to new state-of-the-art results for large language model quantization."
        },
        {
            "section_id": "6",
            "parent_section_id": null,
            "section_name": "Limitations",
            "text": "More experiments may be needed for LLM evaluation. LLMs are being applied to a wide range of tasks, posing high demands on various model abilities.\nWhen quantizing LLMs to low bits, these abilities may be affected to varying degrees. Therefore, a comprehensive evaluation is required to gauge the capabilities of quantized LLMs. Although we experiment on several downstream tasks, such as PPL, MMLU, commonsense QA, and MT-bench, we note that this may not be enough to assess all abilities of LLMs. For example, how long context affects quantized models still remains unknown."
        },
        {
            "section_id": "7",
            "parent_section_id": null,
            "section_name": "Ethics Statement",
            "text": "The development of LLM quantization techniques can further democratize LLMs, lowering the costs of LLM serving and enabling more people to get access to advanced AI assistants. Nonetheless, LLM itself may inherit certain social biases from training data concerning gender, race, etc. Quantization can not mitigate such biases. Therefore, caution must be taken when using quantized LLMs."
        }
    ]
}