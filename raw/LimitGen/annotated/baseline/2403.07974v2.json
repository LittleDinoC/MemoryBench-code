{
    "title": "LiveCodeBench: Holistic and Contamination Free Evaluation of Large Language Models for Code",
    "abstract": "Large Language Models (LLMs) applied to code-related applications have emerged as a prominent field, attracting significant interest from both academia and industry. However, as new and improved LLMs are developed, existing evaluation benchmarks (e.g., MBPP) are no longer sufficient for assessing their capabilities. In this work, we propose LiveCodeBench, a comprehensive and contamination-free evaluation of LLMs for code, which collects new problems over time from contests across three competition platforms, namely LeetCode, AtCoder, and CodeForces. Notably, our benchmark also focuses on a broader range of code-related capabilities, such as self-repair, code execution, and test output prediction, beyond just code generation. Currently, LiveCodeBench hosts over five hundred coding problems that were published between May 2023 and May 2024. We have evaluated base LLMs and instruction-tuned LLMs on LiveCodeBench. We present empirical findings on contamination, holistic performance comparisons, potential overfitting in existing benchmarks as well as individual model comparisons. We will release all prompts and model completions for further community analysis, along with a general toolkit for adding new scenarios and models.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "Code has emerged as an important application area for LLMs, with a proliferation of code-specific models and their applications across various domains and tasks such as program repair, optimization, test generation, documentation generation, tool usage, SQL, and more. In contrast with these rapid advancements, evaluations have remained relatively stagnant, and current benchmarks like MBPP and APPS may paint a skewed or misleading picture. Firstly, while coding is a multi-faceted skill, these benchmarks only focus on natural language-to-code tasks, thus overlooking broader code-related capabilities. Moreover, these benchmarks may be subject to potential contamination or overfitting, as benchmark samples are present in the training datasets.\n\nMotivated by these shortcomings, we introduce LiveCodeBench, a holistic and contamination-free benchmark for evaluating code capabilities. LiveCodeBench is built on the following principles:\n\nLive updates to prevent contamination. LLMs are trained on massive inscrutable corpora, and current benchmarks suffer from the risk of data contamination as they could be included in those training datasets. While previous works have attempted decontamination using both exact and fuzzy matches, it can be a non-trivial task and can be evaded using simple strategies like rephrasing. Here, to prevent the risk of problem contamination, we use live updates, that is, evaluate models on new problems. Particularly, we collect problems from weekly contests on competition platforms and tag them with a release date. Next, for newer models, we only consider problems released after the model’s cutoff date to ensure that the model has not encountered the exact problem in the training dataset. In Figure 1, we find that the performance of the DeepSeek model starkly drops when evaluated on the LeetCode problems released after August. Similarly, GPT-4-O observes a drop in performance on LeetCode problems released since November 2023, its specified cutoff date. This indicates that these models are likely trained on the older LeetCode problems and time-segmented evaluations allow fair comparisons.\n\nHolistic Evaluation. Current code evaluations primarily focus on natural language to code generation. However, programming is a multi-faceted task that requires a variety of capabilities beyond those measured by code generation. In LiveCodeBench, we evaluate code LLMs on three additional scenarios, listed below:\n\n- Self-Repair: Fix an incorrect program from execution information, evaluating the ability to debug code from feedback. The model is given the natural language problem description, the incorrect program, the test case it fails on, and the execution feedback from that failure. The output should be a correct repaired program.\n- Code Execution: “Execute” a program on an input, evaluating code comprehension ability. The model is given a program and an input, and the output should be the result.\n- Test Output Prediction: Solve the natural language task on a specified input, evaluating the ability to generate testing outputs. The model is given the natural language problem description and an input, and the output should be the output for the problem.\n\nFigure 2 (left) depicts performance on the different scenarios considered in LiveCodeBench.\n\nHigh-quality problems and tests. High-quality problems and tests are crucial for reliable evaluation of LLMs. However, prior works have revealed deficiencies in existing benchmarks. In LiveCodeBench, we source the problems from reputable competition websites whose quality is already validated by the platform users. In addition, for every problem, we provide a good number of tests for meaningful and robust evaluations while still finishing quickly.\n\nBalanced problem difficulty. Competition programming is challenging for even the best-performing LLMs, and most of the current SoTA models achieve close to zero performance on a majority of problems. As a result, they can be unsuitable for meaningful comparing today’s LLMs because the variance in performances is low. Furthermore, the averaging of evaluation scores across problems with different difficulty levels artificially minimizes the differences between models. Therefore, we use problem difficulty ratings (sourced from the competition websites) for filtering the harder problems and classifying problem difficulties to ensure balanced problem difficulty distribution and allow granular model comparisons.\n\nWith these principles in mind, we build LiveCodeBench, a continuously updated benchmark that avoids data contamination. Particularly, we have collected problems from contests across three competition platforms – LeetCode, AtCoder, and CodeForces occurring from May to the present (May) and use them to construct the different LiveCodeBench scenarios.\n\nEmpirical Findings. We have evaluated base models and instruction-tuned models across different LiveCodeBench scenarios. Below, we present the empirical findings from our evaluations, which have not been revealed in prior benchmarks.\n\nContamination. We observe a stark drop in the performance of DeepSeek, GPT-4-O, and Codestral on LeetCode problems released after Aug, Oct, and Jan. These results highlight likely contamination in older problems and time-segmented evaluations prove effective for performing fair comparisons.\n\nHolistic Evaluation. Our evaluations reveal that model performances are correlated across tasks, but the relative differences do"
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Holistic Evaluation",
            "text": "Code capabilities of LLMs are evaluated and compared using natural language to code generation tasks. However, this only captures one dimension of code-related capabilities. Real-world software engineering requires expertise in tasks beyond just generation, such as synthesizing informative test cases, debugging incorrect code, understanding existing code, and writing documentation. These tasks are crucial parts of the software development process and contribute to improving the quality, maintainability, and reliability of the code (Boehm, 2006). This also applies to LLMs, and adopting similar workflows can enable the models to perform better code generation. For example, AlphaCodium (Ridnik et al., 2024) is an intricate LLM pipeline for solving competition coding problems. By combining natural language reasoning, test case generation, code generation, and self-repair, they achieve significant improvements over a naive direct code generation baseline, showcasing the importance of these broader capabilities. Motivated by this, we propose a more holistic evaluation of LLMs in this work using a suite of evaluation setups that capture a broader range of code-related capabilities. Specifically, we evaluate code LLMs in four scenarios, namely code generation, self-repair, code execution, and test output prediction. Our selection criterion was to pick settings that are useful components in code LLM workflows and, in addition, have clear and automated evaluation metrics. Following we describe each of these scenarios in detail.\n\n### Code Generation\nThe code generation scenario follows the standard setup for generating code from natural language. The model is given a problem statement, which includes a natural language description and example tests (input-output pairs), and is tasked with generating a correct solution. The evaluation is performed based on functional correctness, using a set of unseen test cases. We use the Pass@1 metric measured as the fraction of the problems for which the model was able to generate a program passing all tests.\n\n### Self Repair\nThe self-repair scenario is based on previous works that tested the self-repair capabilities of LLMs (Olausson et al., 2023; Shinn et al., 2023; Chen et al., 2023). Here, the model is given a problem statement from which it generates a candidate program (similar to the single-step code generation scenario above). However, in case of a mistake, the model is additionally provided with error feedback (either the exception message or a failing test case in case of incorrect code generation) and is tasked with generating the fixed solution. Similar to the code generation scenario, the evaluation is performed via functional correctness on the final program, i.e. either the single-step correct generation or the attempted repair. We use the Pass@1 metric to measure the combined performance after the repair step.\n\n### Code Execution\nThe code execution scenario involves providing the model with a program snippet consisting of a function along with a test input to the program and tasking it with predicting the output of the program on the input test case. The evaluation is performed via an execution-based correctness metric where the model generation is considered correct if assert f(input) == generated_output passes.\n\n### Test Case Output Prediction\nFinally, we introduce a new task that is designed to study natural language reasoning and test generation. In this task, the model is given the problem statement along with a test case input and is tasked with generating the expected output for that input. This task follows a setup similar to the one used in CodeT (Chen et al., 2022), where tests are generated solely from problem statements, without the need for the function’s implementation. A key difference is that we provide a fixed set of test inputs for each problem in our dataset, and the models are then prompted to only predict the expected output for those specific inputs. This approach allows for a straightforward evaluation of the test generation capabilities by avoiding test input prediction, a hard-to-evaluate task.\n\nFinally, we would like to point out that LiveCodeBench also offers an extensible framework to add new scenarios in the future. Other relevant settings like input generation, program summarization, optimization, etc., can be integrated with our setup."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "Benchmark Curation",
            "text": "We curate our problems from three coding competition websites: LeetCode, AtCoder, and CodeForces.\nThese websites periodically host contests containing problems that assess the coding and problem-solving skills of participants.\nThe problems consist of a natural language problem statement along with example input-output examples, and the goal is to write a program that passes a set of hidden tests.\nFurther, thousands of participants participate, solving these problems thus ensuring that the problems are vetted for clarity and correctness."
        },
        {
            "section_id": "3.1",
            "parent_section_id": "3",
            "section_name": "Data Collection",
            "text": "We have written HTML scrapers for each of the above websites to collect problems and the corresponding metadata.\nTo ensure quality and consistency, we parse mathematical formulas and exclude problems with images.\nWe also exclude problems that are not suitable for grading by input-output examples, such as those that accept multiple correct answers or require the construction of data structures.\nBesides parsing the problem descriptions, we also collect associated ground truth solutions and test cases whenever directly available.\nThus for each problem, we collect tuples of natural language problem statement ,\ntest cases , and ground truth solution .\nFinally, we associate the contest date  to mark the release date of each problem and\nuse the collected attributes to construct problems for our four scenarios (detailed in Section 3.3  ###reference_### ahead).\nScrolling through time.\nAs noted, we associate the contest date  for each problem.\nThe release date allows us the measure the performance of LLMs over different time windows by filtering problems\nbased on whether the problem release date falls within a time window (referred to as “scrolling” through time).\nThis is crucial for evaluating and comparing models trained at different times.\nSpecifically, for a new model and the corresponding cutoff date (normalized to the release date if the\ntraining cutoff date is not published),\nwe can measure the performance of the model on benchmark problems released after the cutoff date.\nWe have developed a UI that allows comparing models on problems released during different time windows (shown in Figure 9  ###reference_###).\nTest collection.\nTests are crucial for assessing the correctness of the generated outputs and are used in all four scenarios.\nWe collect tests available on platform websites whenever possible and use them for the benchmark.\nOtherwise, following Liu et al. (2023b  ###reference_b39###), we use a LLM (here GPT-4-Turbo) to generate tests for the problems.\nA key difference between our test generation approach is that instead of generating inputs directly using the LLM, we construct generators that sample inputs based on the problem specifications using in context learning.\nDetails and examples of such input generators can be found in Section A.2  ###reference_###.\nFinally, we collect a small fraction of failing tests from the platform for the more recent problems allowing more directed adversarial test collection.\nProblem difficulty.\nCompetition programming has remained a challenge for LLMs, with GPT-4 achieving an average CodeForces rating (ELO) of 392, placing it in the bottom 5 percentile  (OpenAI, 2023  ###reference_b52###).\nThis makes it difficult to compare LLMs, as the variation in performance across models is low.\nIn LiveCodeBench, we collect problems of diverse difficulties as labeled in competition platforms, excluding problems that are rated above a certain threshold that are likely too difficult for even the best models111From our early explorations, we find CodeForces problems being considerably more difficult than AtCoder and LeetCode problems and thus focus primarily on the latter platforms..\nFurther, we use these ratings to classify problems as Easy, Medium, and Hard for more granular model comparisons."
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "Platform Specific Curation",
            "text": "We describe the curation process for each platform.\nLeetCode.\nWe collect problems from all weekly and biweekly contests on LeetCode that have taken place after April’23.\nFor each problem, we collect the problems, public tests, and user solutions.\nThe platform also provides a difficulty label for each problem which we use to tag the problems as Easy, Medium, and Hard.\nSince LeetCode provides a starter code for each problem, we also collect it and provide it to the LLM in the STDIN format.\nSince the hidden tests are not directly available, we use our generator-based test input generation approach (Section A.2  ###reference_###) and also collect the auto grader failing tests for some of the recent problems.\nAtCoder.\nWe collect problems from the abc (beginner round) contests on AtCoder that have taken place after April’23.\nWe deliberately avoid the more challenging arc and agc contests which are designed for more advanced Olympiad participants.\nThe problems are assigned numeric difficulty ratings, and we exclude abc problems with a rating of more than .\nWe also use these numeric ratings to tag the problems as Easy, Medium, and Hard.\nSpecifically, we use the rating brackets , , and  to perform the classification.\nAtCoder provides public and hidden tests for each problem which we directly use in the benchmark.\nCodeForces.\nWe have collected problems from the Division 3 and Division 4 contests on CodeForces.\nNotably, we find that even with this filter, the problems are harder than the other two platforms.\nCodeForces also provides difficulty ratings for the problems which we use to tag the problems as Easy, Medium, and Hard using the rating brackets , , and  respectively.\nDue to the higher difficulty, we only consider a small fraction of problems from CodeForces and semi-automatically construct test case generators, as they do not provide complete tests on the platform (long tests are truncated).\nTable 1 provides various statistics about the problems that we have collected for LiveCodeBench."
        },
        {
            "section_id": "3.3",
            "parent_section_id": "3",
            "section_name": "Scenario-specific benchmark construction",
            "text": "Code Generation and Self-Repair.\nWe use the natural language problem statement as the problem statement for these scenarios.\nFor LeetCode, as noted above, an additional starter code is provided for the functional input format.\nFor AtCoder and CodeForces problems, we use the standard input format (similar to  Hendrycks et al. (2021  ###reference_b20###)).\nThe collected or generated tests are then used to evaluate the correctness of the generated programs.\nOur final dataset consists of  problem instances across the three platforms.\nCode Execution.\nWe draw inspiration from the benchmark creation procedure used in  Gu et al. (2024  ###reference_b17###).\nFirst, we collect a large pool of  correct, human-submitted solutions from the LeetCode subset.\nHowever, many of these programs have multiple nested loops, complex numerical computations, and a large number of execution steps.\nTherefore, we apply compile-time and run-time filters to ensure samples are reasonable, and we double-check this with a manual inspection.\nMore details on the filtering criteria and statistics of the dataset can be found in Appendix A.3  ###reference_###.\nOur final dataset consists of  samples from  problems.\nTest Case Output Prediction.\nWe use the natural language problem statement from the LeetCode platform and the example test inputs to construct our test case output prediction dataset.\nSince the example test inputs in the problems are reasonable test cases for humans to reason about and understand the problems, they also serve as ideal test inputs for LLMs to process.\nOur final dataset consists of  problem instances from a total of  LeetCode problems."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Experiment Setup",
            "text": "We describe the experimental setup in this section.\nFirst, we provide the common setup across the scenarios, followed by the scenario-specific setups in Section 4.1  ###reference_###.\nModels.\nWe evaluate  models across various sizes, ranging from B to B, including base models, instruction models, and both open and closed models.\nOur experiments include models from different classes, such as GPTs (GPT-3.5-turbo, GPT-4, GPT-4-Turbo,GPT-4-O), Claudes (Claude-Ins-1, Claude-2, Claude-3s), Geminis(Gemini-Pro, Gemini-Flash), Mistral among closed-access and LLaMa-3s(L3-Base-{7, 70}B, L3-Ins-{7, 70}B), DeepSeeks (DS-Base-{1.3, 6.7, 33}B, DS-Ins-{1.3, 6.7, 33}B), CodeLLaMas (CL-Ins-{7, 13, 34}B, CL-Base-{7, 13, 34}B), StarCoder2 (SC2-Base-{3,7,15}B), CodeQwen among open.\nAdditionally, we also include fine-tuned models Phind-34B from CL-Base-34B, and MagiCoders (MC-{6.7, 7}B) from CL-Base-7B and DS-Base-6.7B.\nSee Appendix C.1  ###reference_### for a complete list of models and estimated cutoff dates.\nEvaluation Metrics.\nWe use the Pass@1 (Kulal et al., 2019  ###reference_b27###; Chen et al., 2021  ###reference_b11###) metric for our evaluations.\nSpecifically, we generate  candidate answers for each problem either using API or using vLLM (Kwon et al., 2023  ###reference_b28###).\nWe use nucleus sampling with temperature  and top_p  and calculate the fraction of programs or answers that are correct.\nFor the code generation and self-repair scenarios, we use tests to verify the correctness of the programs. For these scenarios, programs must pass all tests to be considered correct.\nFor the code execution scenario, we use an execution-based correctness metric between the generated output and the ground truth output. For the test output prediction scenario, we parse the generated response to extract the answer and use equivalence checks for grading as specified in Section 2  ###reference_###."
        },
        {
            "section_id": "4.1",
            "parent_section_id": "4",
            "section_name": "Scenario-specific setup",
            "text": "The setup for each scenario is presented below.\nNote that the base models are only used in the code generation scenario since they do not easily follow the format for the other scenarios.\nCode Generation.\nFor the instruction-tuned models, we use a zero-shot prompt and follow the approach of Hendrycks et al. (2021  ###reference_b20###) by adding appropriate instructions to generate solutions in either functional or stdin format.\nFor the base models, we use a constant one-shot example, with a separate example provided for problems that accept stdin input and for problems that accept functional output.\nSection C.2  ###reference_### shows the high-level zero-shot prompt used.\nSelf Repair.\nSimilar to prior work Olausson et al. (2023  ###reference_b51###), we use the programs generated during the code generation scenario\nalong with the corresponding error feedback to build the zero-shot prompt for the self-repair scenario.\nThe type of error feedback includes syntax errors, runtime errors, wrong answers, and time-limit errors, as applicable.\nSection C.3  ###reference_### provides the pseudo-code for computing the error feedback and the corresponding prompt.\nCode Execution.\nWe use few-shot prompts for the code execution scenario, both with and without chain-of-thought prompting (COT).\nParticularly, we use a 2-shot prompt without COT and a 1-shot prompt with COT with manually detailed steps.\nThe prompts are detailed in Section C.4  ###reference_###.\nTest Output Prediction.\nWe use a zero-shot prompt that queries the model to complete assertions, given the problem, function signature, and test input.\nWe provide the prompt in Section C.5  ###reference_###."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Results",
            "text": "We first describe how LiveCodeBench helps detect and avoid benchmark contamination in Section 5.1 ###reference_###.\nNext, we present the findings from our evaluations on LiveCodeBench in Section 5.2 ###reference_###."
        },
        {
            "section_id": "5.1",
            "parent_section_id": "5",
            "section_name": "Avoiding Contamination",
            "text": "A distinguishing aspect of our benchmark is the ability to evaluate models on problems released over different time windows. This allows us to measure the model performance on problems released after the cutoff date, thereby giving a performance estimate on unseen problems. Contamination in DeepSeek and GPT-4-O. LiveCodeBench comprises problems released since May. However, DeepSeek models were released in September and might have already been trained on some of the problems in our benchmark. Similarly, OpenAI notes GPT-4-O cutoff date in November. We can measure the performance of the models on the benchmark using problems released after the cutoff date, thereby estimating the performance of the model on previously unseen problems. Figure 1 shows the performance of these models on LiveCodeBench code generation and test output prediction scenario on LeetCode problems released in different months from May to February. We notice a stark drop in the performance of DS-Ins-33B model after August (right before its release date), which suggests that the earlier problems might indeed be contaminated. This trend is consistent across other LiveCodeBench scenarios like repair and code execution, as depicted in Figure 10. Concurrently, Guo et al. (2024) (Section 4.1, last paragraph) also acknowledge the possibility of LeetCode contamination, noting that “models achieved higher scores in the LeetCode Contest held in July and August. Similarly, performance of the GPT-4-O model drops on problems released since November (its official cutoff date). Interestingly, we find that this drop in performance primarily occurs for the LeetCode problems only and that the model performance is relatively smooth across the months for problems from other platforms. Figure 11 shows a relatively stable performance for all models on AtCoder problems released over different periods, with the possible exception of May and June.\n\nWe study performance variations in other models released recently. Particularly, GPT-4-Turbo, Gemini-Pro, Mistral-L, and Claude-3s models were released in November, December, February, and March respectively. Note that GPT-4-Turbo (-preview variant) and Claude-3s have cutoff dates April and August respectively. Irrespective of the release or cutoff dates, we do not find any drastic performance variations across the months, as shown in Figure 12, particularly compared to the DeepSeek models. Interestingly, we find that even the DS-Base-33B model also suffers from contamination dropping from Pass@1 in May problems to Pass@1 in September LeetCode problems. This also suggests the likely inclusion of competition problems in the pretraining of the DeepSeek models, thereby affecting all instruction models trained from it. Finally, Codestral achieves Pass@1 on problems released between May’23 and January’24 and Pass@1 on problems since February’24."
        },
        {
            "section_id": "5.2",
            "parent_section_id": "5",
            "section_name": "Performance and Model Comparisons",
            "text": "We evaluate instruction-tuned models (and base models used in the code generation scenario) on LiveCodeBench. These models range from closed access to open access with their various fine-tuned variants. To overcome contamination issues in DeepSeek models, we only consider problems released since September for all evaluations below. Figure 4 shows the performance of a subset of models across the four scenarios. We highlight our key findings below.\n\nHolistic Evaluations.\nWe have evaluated the models across the four scenarios currently available in LiveCodeBench. Figure 2 displays the performance of models on all scenarios along the axes of the polar chart. First, we observe that the relative order of models remains mostly consistent across the scenarios. This is also supported by high correlations between Pass@1 metric across the scenarios – over across all pairs as shown in Figure 13. Interestingly, the correlations are larger for related tasks, for generation and self-repair, and for test output prediction and code execution. This correlation drops to for generation and execution scenarios. However, despite the strong correlation, the relative differences in performance do vary across the scenarios. For example, GPT-4-Turbo further gains performance gap over GPT-4 in the self-repair scenario after already leading in the code generation scenario. Similarly, Claude-3-Opus and Mistral-L perform well in tasks involving COT, particularly in the code execution and test output prediction scenarios. For instance, Claude-3-Opus even outperforms GPT-4-Turbo in the test output prediction scenario. Similarly, Mistral-L outperforms Claude-3-Sonnet in both scenarios after trailing behind in code generation and repair scenarios. These differences highlight the need for holistic evaluations beyond measuring code generation capabilities.\n\nHighlighting the gap between SoTA and open models.\nOne distinct observation from our evaluations is the large gap between SoTA models and open models across all scenarios. Particularly, GPT-4-Turbo, GPT-4, Gemini-Pro-1.5 and Claude-3-Opus lead across the benchmarks with wide performance margins over other models. This distinguishes LiveCodeBench from prior benchmarks where various open models have achieved similar or better performance. For instance, consider test output prediction and code execution (with COT) where GPT-4-Turbo leads the DS-Ins-33B model by and respectively! We qualitatively analyze code samples generated by the leading model, GPT-4-Turbo, and find that it generates more readable code. Specifically, the code consists of more inline natural language comments that reason or plan before producing the code. We verify this quantitatively and find GPT-4-Turbo generated uses more comment tokens compared to GPT-4.\n\nComparing Base Models.\nWe use four families of base models – L3-Base, DeepSeek, CodeLLaMa, and StarCoder2 and compare them on the code generation scenario. A one-shot prompt is used for all models to avoid any formatting and answer extraction issues. We find L3-Base and DS models are significantly better than both CodeLLaMa and StarCoder2 base models with a DS-Base-6.7B model even outperforming both CL-Base-34B and SC2-Base-15B models. Next, we observe that SC2-Base-15B also outperforms the CL-Base-34B model. Note that some LiveCodeBench specific differences can potentially be attributed to data curation approaches. For instance, StarCoder2 models use competition problems in the pre-training corpus.\n\nRole of Post Training.\nWe find that post-training improves performance on  LiveCodeBench for the code generation scenario. Particularly, L3-Ins-70B, DS-Ins-33B and Phind-34B achieve Pass@1 on LCB improving over their base models by points respectively. This highlights the importance of good post-training datasets for building strong LLMs. At the same time, we note that the base models have aligned performances on LCB code generation benchmarks and lie within or close to the green shaded region in Figure 5. On the other hand, the closed-access models are still aligned across both benchmarks. This suggests that the fine-tuning data for open models might not be as diverse as that for closed models, leading to a lack of generalization to different kinds of problems.\n\nComparing open-access instruction-tuned models.\nHere, we compare various fine-tuned variants of the L3-Base, DeepSeek and CodeLLaMa base models across different model sizes. We find that fine-tuned L3-"
        },
        {
            "section_id": "6",
            "parent_section_id": null,
            "section_name": "Related Work",
            "text": ""
        },
        {
            "section_id": "6.1",
            "parent_section_id": "6",
            "section_name": "Code Generation",
            "text": "Language Models for Code Generation.\nStarting with Codex (Chen et al., 2021), there are over a dozen code LLMs. These include CodeT5 (Wang et al., 2021, 2023), CodeGen (Nijkamp et al., 2022), SantaCoder (Allal et al., 2023), StarCoder (Li et al., 2023b), AlphaCode (Li et al., 2022), InCoder (Fried et al., 2022), and CodeGeeX (Zheng et al., 2023).\nAs of May 2024, L3-Base and DeepSeek (Bi et al., 2024), StarCoder Lozhkov et al. (2024); Li et al. (2023b) and CodeLLaMa (Roziere et al., 2023) are the most popular open models.\nMany downstream models resulted from fine-tuning them on synthetically generated data, such as WizardCoder (Luo et al., 2023), MagiCoders (Wei et al., 2023b), and Phind-34B.\nCode Generation Benchmarks.\nMany benchmarks have been proposed to compare and evaluate these models.\nThese primarily focus on natural language to Python code generation:\nAPPS (Hendrycks et al., 2021),\nCode-Contests (Li et al., 2022),\nMBPP (Austin et al., 2021),\nL2CEval (Ni et al., 2023).\nTheir variants have been proposed to cover more languages, (Wang et al., 2022a; Zheng et al., 2023; Cassano et al., 2022; Athiwaratkun et al., 2022).\nMany benchmarks have focused on code generation in APIs. Benchmarks like DS-1000 (Lai et al., 2023), ARCADE (Yin et al., 2022), NumpyEval (Zhang et al., 2023b), and PandasEval (Jain et al., 2022) focus on data science APIs.\nOther benchmarks measure using broader APIs or general software engineering tasks, such as JuICe (Agashe et al., 2019), APIBench (Patil et al., 2023), RepoBench (Liu et al., 2023c), ODEX (Wang et al., 2022b), SWE-Bench (Jimenez et al., 2023), GoogleCodeRepo (Shrivastava et al., 2023), RepoEval (Zhang et al., 2023a), and Cocomic-Data (Ding et al., 2022).\nA few benchmarks specifically measure competitive programming, such as APPS (Hendrycks et al., 2021), CodeContests (Li et al., 2022), CodeScope (Yan et al., 2023), xCodeEval (Khan et al., 2023), and LeetCode-Hard (Shinn et al., 2023), and TACO (Li et al., 2023c).\nMethods such as AlphaCode (Li et al., 2022), AlphaCode 2 (Gemini Team et al., 2023), ALGO (Zhang et al., 2023d), Parsel (Zelikman et al., 2022), code cleaning (Jain et al., 2023), code explanations (Li et al., 2023a), analogical reasoning (Yasunaga et al., 2023), and AlphaCodium (Ridnik et al., 2024) have been pushing the boundaries of what is possible with LLMs in this domain. The biggest differentiating factor between LiveCodeBench and these benchmarks is that our benchmark is continuously updated, problem curation with balanced difficulty, higher tests and problem quality, and contains more scenarios such as code repair, code execution, and test output prediction capturing more facets for building agentic coding systems."
        },
        {
            "section_id": "6.2",
            "parent_section_id": "6",
            "section_name": "Holistic Tasks",
            "text": "LiveCodeBench considers self-repair, test output prediction, and code execution as additional scenarios. Below we note pertinent related work for these domains.\n\nCode Repair.\n(Chen et al., 2023; Olausson et al., 2023; Madaan et al., 2023b; Peng et al., 2023; Zhang et al., 2023c) have investigated self-repair for existing code LLM benchmarks. Particularly, these methods use error feedback for models to improve inspiring our code repair scenario.\n\nCode Execution.\nCode execution was first studied in Austin et al. (2021); Nye et al. (2021).\n\nTest Generation.\nTest generation using LLMs has been explored in (Yuan et al., 2023; Schäfer et al., 2024; Tufano et al., 2022; Watson et al., 2020). Furthermore, Chen et al. (2022) demonstrated that LLMs can assist in generating test case inputs/outputs for competitive programming problems, thereby improving the accuracy of the generated code, thus inspiring our test generation scenario. However, LiveCodeBench’s test generation scenario is unique in that it decouples the test inputs and outputs allowing more proper evaluations.\n\nFinally, some works have additionally studied other tasks and scenarios like type prediction (Mir et al., 2022; Wei et al., 2023a; Malik et al., 2019), code summarization (LeClair et al., 2019; Iyer et al., 2016; Barone and Sennrich, 2017; Hasan et al., 2021; Alon et al., 2018), code security (Liguori et al., 2022; Pearce et al., 2022; Tony et al., 2023), etc."
        },
        {
            "section_id": "6.3",
            "parent_section_id": "6",
            "section_name": "Contamination",
            "text": "Data contamination and test-case leakage have received considerable attention as LLMs might be getting trained on benchmarks. Some researchers have demonstrated contamination by prompting the model to reveal its own contamination. To address these issues, various detection methods have been developed to avoid these cases. For code, some use approaches like edit distance and AST-based semantic similarity to detect contamination."
        },
        {
            "section_id": "7",
            "parent_section_id": null,
            "section_name": "Limitations",
            "text": "Benchmark Size.\nLiveCodeBench code generation scenario currently hosts over  instances from problems released between May and February.\nTo account for contamination in DeepSeek, we only perform evaluations on problems released after the model cutoff date.\nThis leads to only  problems used in our final evaluations which might add noise due to problem set samples.\nWe currently estimate  performance variations in LiveCodeBench code generation due to this issue (measured by bootstrapping  sized problem sets from the  sized dataset).\nOther scenarios, i.e. self-repair, code execution, and test output prediction comprise , , and  problems would have similar performance variations.\nWe thus recommend exercising proper judgement when comparing models with small performance differences.\nWe propose two solutions addressing this issue as we evolve LiveCodeBench.\nFirst, we will use other competition platforms for problem collection, allowing larger number of recent problems to be added to the benchmark.\nIn addition, we also hope supplement this with an unreleased private test set constructed specifically for model evaluation.\nThese problems will use a similar flavor to current problems and will be used when models are submitted for evaluation to the LiveCodeBench platform.\nThis would reduce the reliance on public accessible problems and provide a more robust evaluation of the models while providing community public access to similar problems, similar to strategies employed by popular platforms like Kaggle.\nFocus on Python.\nLiveCodeBench currently only focuses on Python which might not provide enough signal about model capabilities in other languages.\nHowever, since we collected problem statements and serialized tests, adding new programming languages would be straightforward once appropriate evaluation engines are used.\nRobustness to Prompts.\nRecent works have identified huge performance variances that can be caused due to insufficient prompt.\nHere, we either do not tune prompts across models or make minor adjustments based on the system prompts and delimiter tokens.\nThis issue can be particularly observed open models on the code execution scenario with COT prompting.\nInterestingly, often the open models perform even worse in comparsion to the direct code execution baseline.\nNote that we used same prompts for the closed models all of which show noticable improvement from COT.\nWhile the used prompts might be sub-optimal, this highlights how open-models perform worse against the closed models at performing chain-of-thought.\nProblem Domain.\nProgramming is a vast domain and occurs in various forms such as programming puzzles, competition programming, and real-world software development.\nDifferent domains might have individual requirements, constraints, challenges, and difficulty levels.\nLiveCodeBench currently focuses on competition problems sourced from three platforms.\nThis might not be representative of the “most general” notion of LLM programming capabilities.\nParticularly, real-world usage of LLMs is drawn upon open-ended and unconstrained problems rasied by users.\nWe therefore recommend using LiveCodeBench as a starting point for evaluating LLMs and\nfurther using domain-specific evaluations to measure and compare LLMs in specific settings as required."
        },
        {
            "section_id": "8",
            "parent_section_id": null,
            "section_name": "Conclusion",
            "text": "In this work, we propose LiveCodeBench, a new benchmark for evaluating LLMs for code. Our benchmark mitigates contamination issues in existing benchmarks by introducing live evaluations and emphasizing scenarios beyond code generation to account for the broader coding abilities of LLMs. LiveCodeBench is an extensible framework that will continue updating with new problems, scenarios, and models. Our evaluations reveal novel findings such as contamination detection and potential overfitting. We hope LiveCodeBench will serve to advance understanding of current code LLMs and also guide future research in this area through our findings."
        }
    ]
}