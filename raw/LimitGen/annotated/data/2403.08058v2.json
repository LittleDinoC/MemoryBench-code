{
    "title": "CHAI: Clustered Head Attention for Efficient LLM Inference",
    "abstract": "Large Language Models (LLMs) with hundreds of billions of parameters have transformed the field of machine learning. However, serving these models at inference time\nis both compute and memory intensive, where a single request can require multiple GPUs and tens of Gigabytes of memory.\nMulti-Head Attention is one of the key components of LLMs, which can account for over 50% of LLMs memory and compute requirement. We observe that there is a high amount of redundancy across heads on which tokens they pay attention to. Based on this insight, we propose Clustered Head Attention (CHAI). CHAI combines\nheads with a high amount of correlation for self-attention at runtime, thus reducing both memory and compute.\nIn our experiments, we show that CHAI is able to reduce the memory requirements for storing K,V cache by up to 21.4% and inference time latency by up to  without any fine-tuning required. CHAI achieves this with a maximum 3.2% deviation in accuracy across 3 different models (i.e. OPT-66B, LLaMa-7B, LLaMa-33B) and 5 different evaluation datasets.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "LLMs have demonstrated remarkable performance on language modelling tasks ranging from question answering, text summarizing, language translation.\nHowever, such performance has been achieved by scaling models to trillions of parameters, and existing works (Hoffmann et al., 2022  ###reference_b22###; Touvron et al., 2023a  ###reference_b45###; Kaplan et al., 2020  ###reference_b26###) show that increasing the model size may lead to even higher model quality.\nInference on LLMs introduce several new challenges. Beyond just the quadratic computation cost of self-attention (Vaswani et al., 2017  ###reference_b47###) with increasing context and large model sizes, LLMs also store intermediate Key (K) and Value (V) pairs for subsequent next word prediction. This K,V caching introduces additional memory related challenges as K,V cache size increases with increase in sequence length.\nThe architecture of widely used LLMs like GPT (Brown et al., 2020  ###reference_b4###) and LLaMa (Touvron et al., 2023a  ###reference_b45###, b  ###reference_b46###) use Multi-Head Attention (MHA) (Vaswani et al., 2017  ###reference_b47###). MHA uses several attention heads to look at a sequence. As models grow bigger, the number of heads increases as well. For example, LLaMa-7B uses 32 attention heads in each layer, while LLaMa-65B uses 64 attention heads per layer (Touvron et al., 2023a  ###reference_b45###).\nThe use of MHA exacerbates bottlenecks for serving LLMs.\nFirst, it increases compute pressure due to repeated application of the attention operation. Second, it increases the memory pressure due to requiring storage of Key (K), Value (V) caches that comes with the additional attention heads.\nTo alleviate these bottlenecks, prior works have introduced primarily two types of methods - (i) pruning of LLMs to utilize sparsity based on the input context (Liu et al., 2023b  ###reference_b33###; Voita et al., 2019  ###reference_b48###) and (ii) Co-designing of the Attention module to reuse components across multiple heads like Multi-Query Attention (MQA) (Shazeer, 2019  ###reference_b41###) and Grouped-Query Attention (GQA) (Ainslie et al., 2023  ###reference_b2###).\n###figure_1### Pruning LLMs can potentially ease the compute bottleneck, however it is challenging as the classical methods for pruning (Frankle & Carbin, 2018  ###reference_b18###; Chen et al., 2020b  ###reference_b6###; You et al., 2019  ###reference_b58###; Waleffe & Rekatsinas, 2020  ###reference_b49###) require fine-tuning or iterative training which is prohibitively expensive for LLMs due to massive memory and compute cost. There have been recent pruning works such as DejaVu (Liu et al., 2023b  ###reference_b33###) which perform pruning based on the context at inference time without requiring fine-tuning. However,\nwe observe that methods like DejaVu are\nprimarily designed for large parameter-inefficient models such as OPT (Zhang et al., 2022  ###reference_b60###) and the insights used to build DejaVu are not directly applicable on newer parameter efficient models like LLaMa-7B (Section 2  ###reference_###). In Figure 1  ###reference_###, we show that CHAI achieves the best trade-off between flops and accuracy compared to the state-of-the-art methods.\nFurthermore,\nruntime pruning methods like DejaVu only reduce the compute cost and have no effect on the large memory requirements of K,V cache.\nThe Attention module co-design methods like GQA (Ainslie et al., 2023  ###reference_b2###) require re-training of LLMs,\ne.g., LLaMa-2 (Touvron et al., 2023b  ###reference_b46###) trained the models from scratch to utilize the benefits of GQA, making it quite expensive. Even in the case where users are willing to perform retraining, accuracy trade-off between GQA and MHA will not be known prior to multiple rounds of training.\nFurther, Attention module co-design methods only reduce the K,V cache size and do not reduce computational complexity.\nTherefore, there is a need for a method, which can reduce both the compute and K,V cache overhead for attention and is - (i) Applicable on a wide range of models (from LLaMa–7B to OPT-66B). (ii) Does not require any fine-tuning or re-training.\nIn this work we present Clustered Head Attention for efficient LLM Inference (CHAI), a dynamic inference time method for efficient LLM inference that does not require fine-tuning.\nCHAI is inspired by two observations. First, several heads in multi-head attention give similar weight to each token in a given sequence, indicating redundant compute.\nIn Figure 2(a)  ###reference_sf1### we show attention scores for a single layer of LLaMa-7B for an auto-regressive decoding step of a sentence. We observe that several heads output similar scores, i.e., giving similar weight to each token in the sequence.\nFigure 2(b)  ###reference_sf2### highlights the similarity in attention score by plotting correlation for the activation for LLaMa-7B. In Figure 2(b)  ###reference_sf2### we observe that there are three clusters and within these clusters the correlation is greater than 0.95.\nThis indicates that by identifying attention heads with similar attention scores and clustering them together we can reduce the number of self-attention operations for MHA by calculating self-attention only for a single head within a cluster.\nSecondly, we observe that for each request to an LLM we can accurately determine the heads which are going to give similar (attention) weight to the tokens in a sequence after running a few decoding steps on the sequence (Section 3.3  ###reference_###). Schematic in Figure 3  ###reference_### depicts both Multi-Head and Clustered-Head Attention.\n###figure_2### ###figure_3### ###figure_4### ###figure_5### Our contributions in this paper are as follows:\nWe show that there is high level of redundancy across several different heads of multi head attention,\nand the redundancy varies differently across layers with increasing redundancy towards later layers.\nWe introduce CHAI, a practical and principled inference time pruning method which clusters attention heads that have similar output together with dynamic determination of clusters. CHAI reduces both compute and K,V cache size for self attention.\nWe show that CHAI is capable of reducing the inference time by up to 1.73 and K,V cache memory size by up to 21.4% compared to MHA for LLaMa models with minimal accuracy trade-off (maximum of 3.2%).\nCompared to other runtime pruning methods like DejaVu, which only works well for OPT models, CHAI outperforms DejaVu and performs well for wider class of models."
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Background and Related Work",
            "text": "We first provide background on inference process for decoder only transformers like GPT (Radford et al., 2019  ###reference_b37###; Brown et al., 2020  ###reference_b4###), LLaMa (Touvron et al., 2023a  ###reference_b45###, b  ###reference_b46###) and the bottlenecks in performing inference.\nFurther, we discussed several prior lines of work which have tried to tackle the inference bottlenecks for transformer based model.\nDecoder-only Transformer A decoder-only transformer forms the building block of popular LLMs. A single decoder block consists of a self attention layer and a MLP. An input token is fed into the decoder block, to perform next-word prediction. The self attention block uses prior query (Q), key (K) and value (V) vectors associated with current token. These tokens are extracted by performing a linear projection with query, key and value weight matrices associated with a transformer.\nTo precisely define Multi-Head Attention (MHA), let , ,  be positive integers, where  denotes number of heads,  denotes sequence length,  denotes model dimension. Let  be input to the MHA layer. For a single head , then ,  and  denote the corresponding key, query and value vector. The attention matrix for head  is calculated as follows:\nOutput of MHA is denoted by:\nFor performing inference, self attention needs access to the query, key and values associated with prior tokens. In order to avoid re-computation, inference serving systems cache the prior tokens in a sequence.\nCompute cost required for multiple attention heads and memory capacity required for storing key and value vectors associated with each head during inference form two primary bottlenecks for LLM inference. In this work, we focus on reducing both memory and compute requirements via clustering multiple attention heads with similar output.\nBuilding Efficient Transformers. Improving efficiency of transformer models has been of major focus in recent years. Prior work can be broadly categorized in the following fields\n- (i) Hardware-software co-design (Dao et al., 2022  ###reference_b11###; Dao, 2023  ###reference_b10###; Ham et al., 2020  ###reference_b20###, 2021  ###reference_b21###; Tambe et al., 2021  ###reference_b43###; Fang et al., 2022  ###reference_b17###; Qin et al., 2023  ###reference_b36###; Wang et al., 2021b  ###reference_b51###), (ii) Knowledge distillation (Hsieh et al., 2023  ###reference_b24###; Jiao et al., 2019  ###reference_b25###; Sanh et al., 2019  ###reference_b40###; Wang et al., 2020  ###reference_b53###) (iii) Neural Architecture Search (NAS) (Zhou et al., 2023  ###reference_b62###; Kitaev et al., 2020  ###reference_b28###; Lagunas et al., 2021  ###reference_b30###) and (iv) Pruning (Voita et al., 2019  ###reference_b48###; Liu et al., 2023b  ###reference_b33###) and Quantization (Frantar et al., 2022  ###reference_b19###; Xiao et al., 2023  ###reference_b56###; Kim et al., 2021  ###reference_b27###; Shen et al., 2020  ###reference_b42###; Dettmers et al., 2022  ###reference_b14###; Dettmers, 2015  ###reference_b12###; Dettmers & Zettlemoyer, 2023  ###reference_b13###). In this work our focus is on pruning , which we discuss next.\nLLM Quantization. Recently several methods have been proposed to perform post training quantization allowing models to be quantized to a lower precision (Frantar et al., 2022  ###reference_b19###; Xiao et al., 2023  ###reference_b56###; Dettmers & Zettlemoyer, 2023  ###reference_b13###). The goal of these methods is to perform quantization so as to minimize the error, CHAI is orthogonal to quantization based mechanisms as it depends on the insight of several attention heads focusing on the same tokens. The goal of quantization methods is to keep the same properties of original models, therefore we believe CHAI can be used to further accelerate post training quantized neural networks.\nLLM Pruning. Pruning is a widely studied method to improve inference time by removing unused weights post training.\nSeveral prior works have looked at pruning for language models (Chen et al., 2020b  ###reference_b6###; Prasanna et al., 2020  ###reference_b35###; Chen et al., 2020a  ###reference_b5###). For example, oBERT is a second order method to reduce the number of weights (Kurtic et al., 2022  ###reference_b29###). Although these approaches can compress a model, they rarely yield inference speedups due to lack of hardware support for sparse operations on modern GPUs. To overcome the challenges, low rank decomposition methods (Wang et al., 2023  ###reference_b52###, 2021a  ###reference_b50###, 2019  ###reference_b54###), attention head pruning (Michel et al., 2019  ###reference_b34###; Voita et al., 2019  ###reference_b48###), layer dropping (Sajjad et al., 2023  ###reference_b39###; Fan et al., 2019  ###reference_b16###; Dai et al., 2023  ###reference_b9###) were proposed. However, these methods are infeasible for LLMs due to the use of iterative gradient calculations or fine-tuning leading to high resource requirements.\nTo overcome these issues, a recently proposed method, DejaVu (Liu et al., 2023b  ###reference_b33###), identifies portions of the model which are unused for a given context. To reduce the overhead of self-attention, DejaVu prunes attention heads which give uniform weight across tokens.\nWe plot the activations for an exemplary sentence used by DejaVu for both OPT-66B and LLaMa-7B in Figure 4  ###reference_###. We observe that while there are heads which give uniform weight to each token in OPT-66B model, there are no such heads in more parameter efficient models like LLaMa-7B, indicating that for smaller parameter efficient models like LLaMa DejaVu might not be applicable. (Additional plots for different layers can be found in Appendix-A  ###reference_###.)\nThe primary difference between OPT and LLaMa activation patterns could be attributed to the fact that LLaMa models are trained significantly longer and with more data.\nWe observe that CHAI’s insight about redundancy in the output of multiple heads in the attention holds across both OPT and LLaMa family of models. In our evaluation (Section 4  ###reference_###), we perform quantitative comparison between CHAI and DejaVu.\n###figure_6### ###figure_7### ###figure_8### ###figure_9### ###figure_10### ###figure_11### ###figure_12### ###figure_13### ###figure_14### ###figure_15### ###figure_16### K,V Cache Compression. Prior works which have tried to reduce the K,V cache size (Liu et al., 2023a  ###reference_b32###; Zhang et al., 2023  ###reference_b61###) by storing the K,V cache values for the most recent important tokens. However, they can not directly improve the latency of generating the next token, as they still perform the full transformer compute before finally deciding which K,V pairs should be stored.\nOn the other hand, CHAI reduces not just the K,V cache size, it is also able to reduce the latency of next word prediction.\nSpeculative Decoding. Speculative decoding (Leviathan et al., 2023  ###reference_b31###; Yang et al., 2023  ###reference_b57###; Xia et al., 2023  ###reference_b55###) is a popular method where a draft model is used to cheaply generate a sequence of draft tokens which can be efficiently verified by a target LLM. Speculative decoding can significantly reduce the latency of LLM serving, however it further exacerbates the compute and memory requirements as it requires additional resources to run both the draft and target model. CHAI on the other hand is focused on reducing the resource required for inference."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "CHAI",
            "text": "Next, we describe CHAI.\nWe first describe the key insights which have been used to build CHAI. Then, we detail CHAI’s runtime pruning algorithm which is inspired by our insights and discuss how we perform inference using CHAI. Figure 5  ###reference_### provides a high level overview of inference using CHAI, which includes offline and online components.\nFigure 6  ###reference_### and Figure 7  ###reference_### indicate that the number of clusters varies widely per layer in a LLM. Specifically, the last few layers in the LLM exhibit a very low number of clusters (high redundancy), whereas the early layers demonstrate a high degree of variance across the output of heads resulting in large number of clusters.\nThis observation suggests that the method used to determine number of clusters needs to make decisions for each layer independently. Additionally, widely used methods such as Elbow plot method (Thorndike, 1953  ###reference_b44###) for determining number of clusters entail manual effort making cluster number determination impractical at inference time.\nDesign.\nTo determine the number of clusters, we propose an offline strategy we run once for each model.\nIn our case, we sample a small number of samples (1024) from the C4 (Raffel et al., 2020  ###reference_b38###) dataset and perform elbow-plot analysis by plotting clustering error (i.e. sum of squared distance from the closest cluster) as a function of number of clusters. Figure 8  ###reference_### shows the clustering error for LLaMa-7B for the samples selected. Based on the Elbow-plot analysis we choose the number of clusters when the error plateaus.\nThe offline analysis is performed once for each network by using the C4 (Raffel et al., 2020  ###reference_b38###) dataset. We do not change the number of clusters determined for a new dataset."
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "Determination of Number of Clusters",
            "text": "Figure 6  ###reference_###  ###reference_### and Figure 7  ###reference_###  ###reference_### indicate that the number of clusters varies widely per layer in a LLM. Specifically, the last few layers in the LLM exhibit a very low number of clusters (high redundancy), whereas the early layers demonstrate a high degree of variance across the output of heads resulting in large number of clusters.\nThis observation suggests that the method used to determine number of clusters needs to make decisions for each layer independently. Additionally, widely used methods such as Elbow plot method (Thorndike, 1953  ###reference_b44###  ###reference_b44###) for determining number of clusters entail manual effort making cluster number determination impractical at inference time.\nDesign.\nTo determine the number of clusters, we propose an offline strategy we run once for each model.\nIn our case, we sample a small number of samples (1024) from the C4 (Raffel et al., 2020  ###reference_b38###  ###reference_b38###) dataset and perform elbow-plot analysis by plotting clustering error (i.e. sum of squared distance from the closest cluster) as a function of number of clusters. Figure 8  ###reference_###  ###reference_### shows the clustering error for LLaMa-7B for the samples selected. Based on the Elbow-plot analysis we choose the number of clusters when the error plateaus.\nThe offline analysis is performed once for each network by using the C4 (Raffel et al., 2020  ###reference_b38###  ###reference_b38###) dataset. We do not change the number of clusters determined for a new dataset."
        },
        {
            "section_id": "3.3",
            "parent_section_id": "3",
            "section_name": "Determination of Cluster Membership",
            "text": "Challenges. Having determined number of clusters, we need to determine the membership of these clusters, i.e., which heads belong to which cluster in each layer.\nFor Figure 6  ###reference_###, 7  ###reference_### and  8  ###reference_###, we perform clustering based on activations obtained by performing the forward pass. However, for each decoding step, performing clustering on output of self attention post forward pass will not yield any performance benefit as we will still be performing the original compute and using the full K,V cache.\nIn order to utilize the insights observed in Section 3.1  ###reference_###, we will need to decide the cluster members without having access to the output of the self attention.\nDesign.\nA simple strategy would have been keeping the cluster membership static across the tokens and independent of input context, e.g., we use the same cluster membership found during offline analysis with C4 data in the previous section.\nFor evaluation purposes we call this version of head selection CHAI-static.\nHowever, we observed that the cluster membership does not remain static and varies based on context.\nWhen comparing Figure 7  ###reference_###, which plots correlation for a single example,\nwith Figure 6  ###reference_###, which plots correlation for 1024 samples, we observe that the correlation across heads varies with varying context. Therefore, the correlation across the output of the heads depends on the context (input prompt), i.e., a solution to determine the membership of each cluster has to account for context.\nTo understand the effects of accounting for context while clustering heads, we analysed the change in cluster membership changes and clustering with different context. In Figure 9  ###reference_###, we observed an interesting phenomenon, after determining cluster membership by accounting for five tokens, the cluster membership does not change frequently. A direct outcome of this observation is that for each new sequence we can perform clustering based on the output of self-attention after the first five tokens. We observe that activation from first five tokens of a new sequence are enough to accurately predict the cluster membership. This dynamic version of head selection further allows us to improve accuracy over CHAI-static.\nFigure 10(b)  ###reference_.sf2### shows an illustration of the membership identification step. Furthermore, evaluation results in Section 4  ###reference_### compare CHAI-static and CHAI performance."
        },
        {
            "section_id": "3.4",
            "parent_section_id": "3",
            "section_name": "Clustered Head Attention",
            "text": "Once we have decided which heads have similar attention output, we can than use Clustered Head Attention to combine key and query vectors for the heads."
        },
        {
            "section_id": "3.5",
            "parent_section_id": "3",
            "section_name": "Inference using CHAI",
            "text": "Next we, discuss the inference flow of CHAI, illustrated in detail in Figure 10  ###reference_###.\nFor each new model we first perform offline cluster identification (Figure 10(a)  ###reference_.sf1###). Then for each new request, we determine the cluster membership using K-Means clustering once we have processed five tokens, using the observed activations (Figure 10(b)  ###reference_.sf2###). After this step, we keep the clustered heads same throughout inference (Figure 10(c)  ###reference_.sf3###).\nThere are two direct outcomes of CHAI’s design. First, we directly reduce the amount of computation by removing redundant heads. Secondly, after a pre-determined token we fix the heads which are going to be pruned, this also allows us to remove the corresponding Key tokens associated, which significantly reduces the K,V cache size.\nTherefore, CHAI allows us to reduce both the inference compute as well as the size of the K,V cache required."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Evaluation",
            "text": "We experimentally verify the performance of CHAI and compare it to DejaVu (Liu et al., 2023b  ###reference_b33###) and SpAtten (Wang et al., 2021b  ###reference_b51###) on three different models of various sizes LLaMa-7B (Touvron et al., 2023a  ###reference_b45###), LLaMa-33B and OPT-66B (Zhang et al., 2022  ###reference_b60###). We evaluate the models on five commonly used NLP tasks: PIQA (Bisk et al., 2020  ###reference_b3###), HellaSwag (Zellers et al., 2019  ###reference_b59###), Arc-Challenge and Arc-Easy (Clark et al., 2018  ###reference_b8###) and BoolQA (Clark et al., 2019  ###reference_b7###)."
        },
        {
            "section_id": "4.1",
            "parent_section_id": "4",
            "section_name": "Experimental Setup",
            "text": "All our experiments are performed on servers with NVIDIA V100 GPUs. For OPT-66B we used eight GPUs on a single node, for LLaMa-33B we used four GPUs, and for LLaMa-7B, we used a single GPU for inference. CHAI is built on top of Meta’s xFormers (facebookresearch, 2023  ###reference_b15###)."
        },
        {
            "section_id": "4.2",
            "parent_section_id": "4",
            "section_name": "Accuracy Evaluation",
            "text": "In our evaluation, we compare CHAI with Multi-Head Attention as baseline, static version of CHAI, as well two other state-of-the-art prior pruning methods; DejaVu and SpAtten.\nFor DejaVu, we try different sparsity ratios, in order to try to match the accuracy number to MHA. We also compare CHAI to SpAtten, a method which removes unimportant tokens and heads.\nIn Table 1  ###reference_###, we first verify that we are able to reproduce the performance numbers reported by DejaVu. To perform this, we took the OPT-66B and evaluated both DejaVu, CHAI and CHAI-static. We used DejaVu with 50% sparsity as reported by the authors.\nWe used the author provided code to train their MLP predictor layers and incorporate their scheme in our setup.\nIn Table 1  ###reference_###, we observe that we were able to replicate results for OPT-66B. Furthermore, CHAI is also able to match the accuracy of MHA for OPT-66B.\nNext, we compare CHAI, CHAI-static and DejaVu with the pre-trained MHA network, using LLaMa-7B on 5 different datasets.\nFor DejaVu we used three configurations, 50% sparsity, 30% sparsity and 10% sparsity.\nIn Table 2  ###reference_###, we observe that when we use DejaVu with more 10% sparsity we see significant decrease in accuracy (by 18.6% for DejaVu-30%). On the other hand, our method based on our close analysis of the behaviour of layers of LLaMa-7B is able to recover accuracy. We observe a maximum accuracy degradation of 3.7% for CHAI.\nSimilarly for LLaMa-33B using sparsity for more than 10% leads to significant accuracy drop, meanwhile CHAI closely matches the accuracy of the pre-trained model using MHA with maximum degradation in accuracy by 0.14%.\nThis shows that CHAI is widely applicable across multiple datasets and models.\nWe also want to highlight that we do not perform any dataset specific tuning."
        },
        {
            "section_id": "4.3",
            "parent_section_id": "4",
            "section_name": "Reduction in K,V Cache Memory Requirement",
            "text": "In this section, we study the memory capacity reduction achieved by use of CHAI due to reduction in K,V cache size.\nIn Figure 11  ###reference_###, we show that for LLaMa-7B CHAI reduces the size of K,V cache by up to 21.4% compared to MHA.\nEven for comparatively small models like LLaMa-7B, the size of the K,V cache for a sequence length of 2048 is around 1.2 GB, while around 12 GB is used for the model weights. A reduction in K,V cache size can enable use of larger context length or serving more requests.\nWe would also like to note that as shown in Figure 3  ###reference_###, CHAI only removes the keys associated with redundant heads and keeps all the value vectors.\n###figure_22### ###figure_23### ###figure_24###"
        },
        {
            "section_id": "4.4",
            "parent_section_id": "4",
            "section_name": "End-to-End Latency",
            "text": "Next, we evaluate time to first token and time to next token comparing it with MHA. These are two standard metrics used for evaluation of an LLM. Time to first token evaluates the time for generating a first token given a new context. Time to first token accounts for generating K,V caches for all the tokens in the context. Whereas time to next token evaluates the time for generating the next token, assuming the K,V caches for all internal tokens is available.\nTime to first token.\nNext, in our experiments we compare the speedups provided by CHAI. In Figure 12  ###reference_###-(a) for LLaMa-7B we show that our method provides speedup of up to  on a sequence length of 2048.\nThe execution times represented in this figure accounts for the overhead of clustering in CHAI.\nTime to next token.\nAnother metric for evaluation of LLMs is time to next token. We do not account for the overhead of clustering in the case of time to next token. Our primary wins come from reducing compute and reducing memory bandwidth requirement for performing time to next token.\nFigure 12  ###reference_###-(b) shows time to predict the next token for different sequence lengths. We observe that CHAI provides a speedup of over  for a sequence length of 2048.\nUnfortunately, we are not able to compare times with DejaVu as the authors have not released the specialized kernels used for realizing the speedups on hardware (git, 2024  ###reference_b1###),\nthus inhibiting a runtime comparison. However, we believe it is unlikely that at less than 10% sparsity which is needed by DejaVu to get comparable accuracy to MHA, it will yield high speedups (Hooker, 2021  ###reference_b23###).\nWe would like to highlight that because of performing dense computations, unlike DejaVu, CHAI does not need custom GPU kernels. Further, CHAI’s speedup benefits are independent of the framework used, because irrespective of implementation, CHAI directly reduces the complexity of MHA.\n###figure_25###"
        },
        {
            "section_id": "4.5",
            "parent_section_id": "4",
            "section_name": "Additional Experiments",
            "text": "Next we perform additional studies on our algorithm.\nPruning K, Q and V.\nIn CHAI, we prune only the Key and Query portion of an attention head leaving the Value vector intact. Next, we study how accuracy changes if we remove the value vector as well.\nTo perform this experiment we chose to reuse the value vector generated by the chosen head.\nIn Table 4  ###reference_###, we show how reusing the full head (Query, Key and Value vector) lead to additional loss in accuracy. This shows that for smaller networks like LLaMa it might be hard to remove the whole head in Multi-Head Attention.\nCluster Distribution.\nFigure 13  ###reference_### shows the distribution across clusters for Layer-18 on LLaMa-7B for different 1024 samples of C4 dataset. We observe that typically for LLMs majority of heads can be grouped into a single head."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Conclusion",
            "text": "In this work, we present CHAI, an efficient runtime method which identifies attention heads giving similar scores. Using this method we reduce overhead of Multi-Head Attention by clustering the correlated heads and computing attention scores only for heads which lead to disparate attention scores. Our evaluation shows that with minor accuracy loss system can speedup inference by up to ."
        }
    ]
}