{
    "title": "Using Contextual Information for Sentence-level Morpheme Segmentation",
    "abstract": "Recent advancements in morpheme segmentation primarily emphasize word-level segmentation, often neglecting the contextual relevance within the sentence. In this study, we redefine the morpheme segmentation task as a sequence-to-sequence problem, treating the entire sentence as input rather than isolating individual words. Our findings reveal that the multilingual model consistently exhibits superior performance compared to monolingual counterparts. While our model did not surpass the performance of the current state-of-the-art, it demonstrated comparable efficacy with high-resource languages while revealing limitations in low-resource language scenarios.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "The problem of morpheme segmentation deals with decomposing a word into a sequence of morphemes that represent the smallest meaningful unit of words like prefixes, suffixes, and root words. For example, the word pokers can be decomposed into its morphemes as poke@@er@@s, where @@ represents separations between morphemes.\nRecent advances in morpheme segmentation focus mostly on word-level segmentation (Batsuren et al., 2022  ###reference_b1###; Peters and Martins, 2022  ###reference_b5###) and do not take the context of the word in the sentence into consideration. Instead, we focus on the task of sentence-level morpheme segmentation in which the context of the word in a sentence is taken into account for morpheme segmentation.\nThe SIGMORPHON 2022 Shared Task on Morpheme Segmentation (Batsuren et al., 2022  ###reference_b1###) formulates the task of morpheme segmentation into two subtasks: word-level segmentation and sentence-level segmentation. Although many submissions in this task show significant improvements over baselines on both subtasks (Rouhe et al., 2022  ###reference_b7###; Wehrli et al., 2022  ###reference_b12###; Peters and Martins, 2022  ###reference_b5###), most submitted approaches for sentence-level segmentation subtask ignore the context of words by design treating the problem as word-level morpheme segmentation, i.e. they treat each word in a sentence as a separate example.\nHowever, in many languages, the context of a word might provide a piece of meaningful information to disambiguate the morphology of the word (Batsuren et al., 2022  ###reference_b1###) and help improve morpheme segmentation.\nConsider the following sentences in Mongolian and their corresponding morpheme segmentation:\nГэрт эмээ хоол хийв.  Гэр @@т эмээ хоол хийх @@в.\nБи өдөр эмээ уусан.  Би өдөр эм @@ээ уух @@сан.\nIn the above examples, the word эмээ has different meanings in each sentence. In the first sentence, it means grandmother and is not segmentable. However, in the second one, it means medicine and is segmentable as эм @@ээ. Therefore, the context of a word in a sentence is an important factor for determining how the word should be segmented into its morphemes.\nWe focus on the task of sentence-level morpheme segmentation while taking the whole sentence in context and implement a sequence-to-sequence transformer model (Vaswani et al., 2017  ###reference_b10###) inspired by DeepSPIN-3 (Peters and Martins, 2022  ###reference_b5###) which is the winner of word-level morpheme segmentation in the SIGMORPHON 2022 Shared Task on Morpheme Segmentation (Batsuren et al., 2022  ###reference_b1###).\nWhile most existing methods treat sentence-level morpheme segmentation as a zero-shot solution of word-level morpheme segmentation (Batsuren et al., 2022  ###reference_b1###), we treat each sentence as a whole as one training example to preserve its context and treat the problem as a sequence to sequence generation task. The sentence-level dataset provided for the shared task consists of three languages: Czech, English, and Mongolian.\nWe perform various experiments with monolingual and multilingual sequence-to-sequence transformer models and show that the multilingual model generally performs better over monolingual models, especially for low-resource languages. Additionally, we experiment with data augmentation in which we increase the training dataset by combining samples for word-level morpheme segmentation. We also experiment with upsampling the sentence-level data given the lack of enough training data for low-resource languages like Czech and Mongolian. Although we are not able to outperform the winners of the shared task, our results are close for high resource languages like English (F1 score: 95.10) but relatively underperform for low-resource languages like Czech (F1 score: 75.79) and Mongolian (F1 score: 72.54)."
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Approach",
            "text": "We implement sequence to sequence transformer model similar to DeepSPIN-3 (Peters and Martins, 2022  ###reference_b5###) for sentence-level morpheme segmentation while treating each sentence as one training example.\nOur implementation is done using fairseq (Ott et al., 2019  ###reference_b4###).\nThis sequence-to-sequence task setting for sentence-level morpheme segmentation is similar to machine translation settings but differs in the sense that the source language corresponds to sentence examples and the target language corresponds to the sentence in which the words are segmented into their corresponding morphemes.\nWe train monolingual and multilingual models with the same transformer architecture.\nThe overall approach for both monolingual and multilingual models are described below."
        },
        {
            "section_id": "2.1",
            "parent_section_id": "2",
            "section_name": "Tokenization",
            "text": "We use Google’s SentencePiece tokenizer with subword regularization using Unigram Language Model (ULM) (Kudo, 2018  ###reference_b3###).\nULM is a top-down technique where the model is initially initialized with a vast vocabulary of overlapping sub-words and a score is generated based on expectation maximization for each sub-word.\nUp until the anticipated vocabulary size is attained, the lowest-scoring sub-words are trimmed.\nThe SentencePiece tokenizer is trained using both source and target data, and all tokens for sentence-level data are pre-computed before training as expected by fairseq’s training workflow.\nThe vocabulary size for English is chosen to be 6000 to 8000 for English and 1000 to 5000 for Czech and Mongolian depending upon the data augmentation which could allow for higher vocabulary sizes.\nAdditionally, for multilingual model, we use the vocabulary size to be 9000 to 12000 so as to take into account a large number of diverse tokens present in multiple languages."
        },
        {
            "section_id": "2.2",
            "parent_section_id": "2",
            "section_name": "Model Architecture",
            "text": "Our transformer model (Vaswani et al., 2017  ###reference_b10###) consists of 6 encoder and 6 decoder blocks with 8 multi-head attentions.\nWe use an embedding size of 256 and dropout of 0.3 determined through hyperparameter tuning on the dev set.\nThe size of each feed-forward layer is 1024 which is also determined through hyperparameter tuning on the dev set.\nWe use identical architecture for all three languages: Czech, English, and Mongolian."
        },
        {
            "section_id": "2.3",
            "parent_section_id": "2",
            "section_name": "Training",
            "text": "We train for a maximum of 400,000 updates and perform early stopping based on the validation loss.\nWe use learning rate warm-up for 4000 steps for different languages determined through hyperparameter tuning.\nWe also use inverse square root learning rate scheduling during our training. We use a batch size of 8192 for all the experiments.\nOur model is trained using entmax-loss (Peters et al., 2019  ###reference_b6###) with alpha of 1.5 similar to Peters and Martins (2022  ###reference_b5###) since it seemed to show better performance compared to cross-entropy loss in our preliminary experiments.\nThe entmax loss is a general family of loss functions encompassing the cross-entropy loss as a special case (when alpha=1). Using values greater than 1 for alpha, the entmax loss allows for sparse gradients with non-zero values occurring only on the gold label and/or other labels that receive non-zero probability. This means that completely-peaked probability distributions are possible, in contrast to the denser distributions observed at alpha=1.”\nThis makes entmax loss a better choice over cross-entropy loss in many applications.\nHowever, entmax loss is computationally more expensive to compute than cross-entropy loss.\nWe therefore use existing implementation of entmax loss rather than implementing it from scratch."
        },
        {
            "section_id": "2.4",
            "parent_section_id": "2",
            "section_name": "Inference and Evaluation",
            "text": "For generating morpheme segmentation for each sentence, we use beam search with a beam size of 5.\nThe tokenizer trained using the training data is used to tokenize sentences during inference.\nAdditional postprocessing is done to clean up raw output from the model to obtain final segmentation.\nWe use F1 score as our primary metric to evaluate the morpheme segmentation at the sentence-level.\nThis means that the generated segmentation for a sentence is considered to be correct only if all the words in that sentence is segmented correctly.\nPrecision, recall and Levenshtein distance, although computed, have not been reported in this paper.\n###table_1###"
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "Experiments",
            "text": "We evaluate our approach on the sentence-level morpheme segmentation dataset provided by Batsuren et al. (2022  ###reference_b1###).\nThis dataset consists of train, dev and test samples in Czech, English and Mongolian languages as shown in Table 2  ###reference_###.\nWe experiment with monolingual models (separate models for each language) and multilingual model (one model for all languages) that are discussed below."
        },
        {
            "section_id": "3.1",
            "parent_section_id": "3",
            "section_name": "Monolingual Experiments",
            "text": "We experiment with monolingual models in which we train three different models separately on Czech, English and Mongolian datasets.\nWe conduct few different experiments using the sequence to sequence transformer model as described in 2  ###reference_### using only the sentence-level dataset, augmenting with word dataset and upsampling the dataset."
        },
        {
            "section_id": "3.1.1",
            "parent_section_id": "3.1",
            "section_name": "3.1.1 Sentence-level Dataset Only",
            "text": "In this experiment, we take the sentence-level dataset in three languages and train the sequence to sequence transformer model for each of these languages.\nThe results are shown in the Table 1  ###reference_### (second row).\nWe observe that for high resource language like English, the F1 score is 87.94 while drops significantly for low-resource language likes Czech (F1 score: 22.62) and Mongolian (F1 score: 21.00)."
        },
        {
            "section_id": "3.1.3",
            "parent_section_id": "3.1",
            "section_name": "3.1.3 Word-level Dataset Augmentation",
            "text": "Another way to increase the number of training data we employ is to augment the sentence-level training set with word-level dataset from their corresponding languages.\nThe results with word-level datset augmentation are shown in Table 1  ###reference_### (fourth row).\nWe observe that augmenting the word-level dataset significantly improves the F1 score for English to 92.46 compared to 87.94 obtained without any upsampling or word-level dataset augmentation.\nHowever, there is only small improvement for Czech language (from 22.62 without any upsampling or word-level dataset augmentation to 25.87 in this case).\nSurprisingly, augmenting the word-level dataset reduced the performance for Mongolian language.\nThis could be because of the prevalence of context-dependent morpheme segmentation examples like the one discussed in Sec. 1  ###reference_###.\nWe believe that understanding the core reason for this drop in performance might require knowledge of Mongolian language’s morphology."
        },
        {
            "section_id": "3.1.4",
            "parent_section_id": "3.1",
            "section_name": "3.1.4 Word Augmentation with Upsampling",
            "text": "We combine word-level data augmentation and then perform upsampling similar to Sec. 3.1.2  ###reference_.SSS2### and use this dataset to train the transformer model.\nThe results are shown in Table 1  ###reference_### (fifth row).\nWe observe that this achieves the highest overall F1 score of 95.10 for English. We also see improvements for Czech with F1 scores of 46.62.\nAlthough there is improvement for Mongolian with F1 score of 38.00 compared to word-level dataset augmentation, this is still lower than F1 score of 39.40 obtained with upsampling, and therefore this improvement is most likely only contributed by upsampling rather than word-level dataset augmentation which most likely slightly hampered the performance instead."
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "Multilingual Experiments",
            "text": "We experiment with multilingual model in which we concatenate training datasets from Czech, English and Mongolian into one large multilingual dataset and train one tokenizer model and one sequence-to-sequence transformer on this multilingual dataset.\nWe do not use any language identifier token to identify the samples from different languages and instead perform simple concatenation only.\nWe also experiment with word-level dataset augmentation and then perform upsampling on this augmented multilingual dataset since this approach demonstrated better performance with monolingual models.\nThe results are shown in Table 1  ###reference_### (middle block).\nWe observe that the multilingual model outperforms monolingual models for Czech and Mongolian in which the F1 scores are 75.79 and 72.54 respectively. This shows that Czech and Mongolian languages significantly benefited from multilingual settings.\nFor English, the performance drops slightly to 92.93 in multilingual settings from 95.10 in monolingual settings. Overall, we observe that low-resource languages see much more performance improvements in multilingual settings as expected."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Related Work",
            "text": "Many NLP applications require tokenization of words into subwords. However, most subword tokenization approaches like Byte-Pair Encoding (BPE) (Gage, 1994  ###reference_b2###; Sennrich et al., 2016  ###reference_b9###) and Unigram Language Model (ULM) (Kudo, 2018  ###reference_b3###) ignore the morphophology of words during tokenization and instead tokenize words based on statistical co-occurence of subwords.\nBatsuren et al. (2022  ###reference_b1###) proposed SIGMORPHON 2022 Shared Task on Morpheme Segmentation citing the necessity of linguistically motivated subword tokenization in which many approaches demonstrated state-of-the-art performance over existing baseline systems like WordPiece (Schuster and Nakajima, 2012  ###reference_b8###), ULM (Kudo, 2018  ###reference_b3###) and Morfessor2 (Virpioja et al., 2013  ###reference_b11###).\nFor example, DeepSPIN-2 and DeepSPIN-3 (Peters and Martins, 2022  ###reference_b5###) collectively demonstrate a superior performance on word-level morpheme segmentation on all 9 languages considered on the shared task.\nAUUH (Rouhe et al., 2022  ###reference_b7###), CLUZH (Wehrli et al., 2022  ###reference_b12###) and others also show significantly improved performance over baselines for both subtasks.\nHowever, most submitted approaches ignore the context of words in a sentence for sentence-level morpheme segmentation.\nOur approach formulates sentence-level morpheme segmentation by considering sentence as a whole to preserve the context (including the unofficial highest scorer DeepSPIN-sent) and performs morpheme segmentation without separating the sentence into individual words before morpheme segmentation."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Conclusion and Future Work",
            "text": "Our results show that our approach with multilingual model shows better performance over monolingual models.\nAdditionally, the performance improvement is more significant for low-resource languages like Czech and Mongolian than English for which comparatively large amount of training data was available.\nWe also show that word-level dataset augmentation and data upsampling show improved performance particularly for low resource languages. In this regard, we emphasize that simple techniques like data upsampling could serve as a first step for low-resource languages in some NLP tasks.\nOverall, although our results do not outperform state of the art, they are competitive for high-resource languages like English and have the potential for improved performance upon tackling issues with regards to the lack of enough data for low-resource languages like Czech and Mongolian.\nFuture directions of this research could try to tackle lack of enough data for low-resource languages by investigating techniques like semi-supervised learning in which a trained model is used to generate labels for newly collected data and then integrate this newly labelled data to expand the training data if the predicted probabilities for the labels cross certain threshold. This could help generate new labelled data that could then be used to train new models. Additionally, our multilingual model do not distinguish between language samples. Adding an additional language identifier token in data based on language could potentially help improve the performance of multilingual model further."
        }
    ]
}