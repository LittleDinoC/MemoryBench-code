{
    "title": "Branch-Train-MiX: Mixing Expert LLMs into a Mixture-of-Experts LLM",
    "abstract": "We investigate efficient methods for training Large Language Models (LLMs) to possess capabilities in multiple specialized domains, such as coding, math reasoning and world knowledge. Our method, named Branch-Train-MiX (BTX), starts from a seed model, which is branched to train experts in embarrassingly parallel fashion with high throughput and reduced communication cost. After individual experts are asynchronously trained, BTX brings together their feedforward parameters as experts in Mixture-of-Expert (MoE) layers and averages the remaining parameters, followed by an MoE-finetuning stage to learn token-level routing. BTX generalizes two special cases, the Branch-Train-Merge method, which does not have the MoE finetuning stage to learn routing, and sparse upcycling, which omits the stage of training experts asynchronously. Compared to alternative approaches, BTX achieves the best accuracy-efficiency tradeoff.",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "In recent years, Large Language Models (LLMs) have shown impressive performance in a wide-range of tasks\n(Brown et al., 2020  ###reference_b7###; Touvron et al., 2023  ###reference_b37###; Achiam et al., 2023  ###reference_b1###), including code generation (Li et al., 2022b  ###reference_b28###; Rozi√®re et al., 2023  ###reference_b31###), solving math problems (Azerbayev et al., 2023  ###reference_b5###), multilinguality (Zhao et al., 2024  ###reference_b42###), etc.\nTraining such LLMs requires a large amount of compute and data, exceeding thousands of GPUs and trillions of tokens.\nThe training parallelization is typically done by maintaining multiple copies of the model on different GPUs and keeping them synchronized after each weight update.\nThe cost of this frequent communication is the main bottleneck in scaling the training to more GPUs.\nBesides this issue, synchronized training is more vulnerable to hardware failures as a single failed GPU can cause the whole training to halt (Zhang et al., 2022  ###reference_b41###; Gemini Team, 2023  ###reference_b14###).\nRecent work by Li et al. (2022a  ###reference_b27###) proposed the Branch-Train-Merge (BTM) method for embarrassingly parallel training of LLMs without any synchronization for improving the throughput of pretraining.\nIt starts by creating multiple copies of a seed LLM, then separately training each copy on different subsets of data.\nThis results in multiple independent LLMs that do not share any parameters and each LLM is an expert specializing in its own data distribution, such as knowledge domains, languages or even modalities.\nAt test time, an input prompt is classified into one or more of the domains, and then the final outputs are formed from the corresponding expert models which are combined to predict the next token.\nWhile this approach makes training more efficient, its main drawback is the lack of a unified single model making it impossible to do further supervised finetuning (SFT) or reinforcement learning from human feedback (RLHF) finetuning (Ouyang et al., 2022  ###reference_b29###), both of which can boost performance further, and are crucial steps in building aligned LLMs.\nA separate line of work for reducing the computational footprint of LLMs is the Mixture-of-Experts (MoE) approach (Jacobs et al., 1991  ###reference_b19###; Shazeer et al., 2017  ###reference_b36###), where only a subset of parameteters are active at any given time.\nIn particular, MoE is applied to the feedforward sublayer of Transformers (Fedus et al., 2022  ###reference_b13###; Roller et al., 2021  ###reference_b30###; Lewis et al., 2021  ###reference_b26###), allowing the total number of parameters to grow without additional computation.\nLLMs scaled in this way have shown impressive performance on downstream tasks (Jiang et al., 2024  ###reference_b21###; Xue et al., 2024  ###reference_b39###). Unlike Branch-Train-Merge, Mixture-of-Experts are often trained in a fully synchronized fashion, and the communication cost increases with the number of experts due to all-to-all communication.\nIn this paper, we aim for the best of both worlds, combining the advantages of Branch-Train-Merge and Mixture-of-Experts, while mitigating their disadvantages.\nWe achieve this by training multiple expert LLMs separately as in the Branch-Train-Merge method, but subsequently combine those experts into a single model using an MoE architecture.\nMore specifically, the feedforward sublayers from all the expert LLMs are brought together into a single MoE module at each layer, and a router network selects which feedforward expert to use at every token.\nWe merge other modules of the expert LLMs, including self-attention layers, by simply averaging their weights.\nThen the resulting model is MoE-finetuned\non all the combined data by continuing training, so that the router can learn to mix the expert feedforward (FF) modules.\nFigure 1  ###reference_### shows an overview of this method, which we call Branch-Train-MiX (BTX).\nThe main advantage of BTX compared to MoE is that expert training is embarrassingly parallel and asynchronous, reducing communication cost and increasing training throughput.\nCompared to Branch-Train-Merge, the final BTX model is a unified neural network that can be finetuned or used like any other standard LLM.\nThe final BTX model will not significantly increase inference FLOPs compared to the seed model since it is sparsely activated, despite having a much larger number of parameters.\nWe conduct our experiments using Llama-2 7B (Touvron et al., 2023  ###reference_b37###) as a seed model and train expert LLMs on different subsets of data corresponding to the domains of math, code and Wikipedia.\nWith the original Llama-2 7B weights added as a fourth expert, we finetune the combined MoE model for a relatively short period compared to the pretraining process.\nThe resulting BTX model brings significant improvements over the seed model on tasks across various domains, especially bridging the gap with specialized models on math and code related tasks, while retaining performance on the original capabilities where specialized models suffer from catastrophic forgetting. BTX outperforms BTM on all tasks demonstrating the benefits of learnt routing through MoE finetuning. Compared to purely MoE training such as sparse upcycling, BTX is more compute efficient with higher training throughput and more balanced performance across tasks in different domains.\n###figure_1###"
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Related Work",
            "text": "Reducing communication between training workers for computational efficiency is a major topic of study for training deep learning systems.\nZhang et al. (2015  ###reference_b40###) introduced a method that allows model instances on different workers to diverge from each other, thus eliminating the constant need of synchronization. Instead, the workers are loosely synchronized to master weights using elastic averaging from time to time.\nA more recent work by Douillard et al. (2023  ###reference_b12###) showed that less frequent synchronization of diverged workers by averaging their weight changes and applying Nesterov momentum works well in practice for training LLMs.\nThe Branch-Train-Merge method (Li et al., 2022a  ###reference_b27###; Gururangan et al., 2023  ###reference_b16###) takes parallel training to the extreme by running multiple training processes completely independently.\nEach training process uses specific domain data, thus the corresponding model becomes an expert in that domain. Finally, the output distributions of those expert models are averaged to make a next token prediction.\nWhich experts to average is decided by classifying the input into one or more of the domains.\nWortsman et al. (2022  ###reference_b38###) showed simply averaging parameters of separately trained models improves performance, but the models only differed in their hyperparameters.\nMoE is used to scale deep networks in Shazeer et al. (2017  ###reference_b36###) using a simple Top-K routing scheme.\nSince the routing decisions are discrete and thus cannot be trained by gradient descent, various training methods have been explored for the Transformer architecture (Fedus et al., 2022  ###reference_b13###; Lewis et al., 2021  ###reference_b26###).\nSurprisingly Roller et al. (2021  ###reference_b30###) showed that even a fixed routing scheme without any learning works well, if the routing is done via a random mapping based on input tokens.\nIn larger scale experiments with recent LLMs, Jiang et al. (2024  ###reference_b21###) demonstrated that the MoE approach can match the performance of dense LLM counterparts using a much smaller number of active parameters.\nA study by Dai et al. (2024  ###reference_b11###) showed the advantage of more fine-grained experts, as well as having a shared expert that always stay active.\nMore similar to our work, Gururangan et al. (2021  ###reference_b15###) makes experts in feedforward layers specialize to specific domains using a domain-conditioned fixed routing, but it lacks the asynchronous training of our approach.\nOur method relates to continual learning (Awasthi and Sarawagi, 2019  ###reference_b4###) because domain experts are trained on datasets with different distributions from the initial data used for training the seed model, which is implemented by continued training after branching.\nSpecifically, our approach is related to parameter isolation methods (Lange et al., 2019  ###reference_b25###) as we have different parameters for different domains.\nAljundi et al. (2016  ###reference_b2###) also creates a new copy of a model to train on each domain.\nRusu et al. (2016  ###reference_b32###) adds a new model with a new domain, but connects it to the previous models so the previously learned features can be used.\nRozi√®re et al. (2023  ###reference_b31###) showed continual training of a seed LLM on a specific domain of code can produce a strong domain expert model, and this converges much faster than starting from scratch.\nFor training a math expert, starting from a code expert rather than a general LLM was shown to be more beneficial (Shao et al., 2024  ###reference_b35###; Azerbayev et al., 2023  ###reference_b5###)."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "Branch-Train-MiX",
            "text": "Given an existing LLM  which has been pretrained on a large corpora covering a wide variety of topics, we aim to improve its performance on  areas of expertise. This is achieved by continued pretraining with corresponding training datasets , each related to a specific knowledge domain such as math, code, etc.\nThe proposed method contains three stages: Branch, Train, and MiX.\nA common problem with MoE is the emergence of dead experts, which do not get activated by the router at all.\nCommon routing methods like Top-k are unlikely to escape from such a situation because a dead expert is never in the top-k selection, and therefore never receives a training signal.\nLoad balancing offers a simple solution by adding an extra loss term that encourages the experts to be utilized equally.\nWe use a loss term similar to (Fedus et al., 2022  ###reference_b13###):\nHere  is the current data batch, and  is a hyperparameter. This loss is computed in each layer and added to the NLL loss.\nBesides Top-k routing, we also experiment with other routing methods:\nSwitch: It is a Top-1 routing method proposed by Fedus et al. (2022  ###reference_b13###).\nSoft routing: We use softmax as the routing function , so all experts are activated both during training and inference. While it is likely to provide the best performance, it comes at the expense of increased compute.\nSample Top-1: We use the gumbel softmax (Jang et al., 2016  ###reference_b20###) for .\nAt training time, we generate a soft sample from the gumbel softmax, but zero out all its values except the largest one. Then we compute only one expert corresponding to this largest value, omitting the other expert computations. At inference time, we simply do hard sampling. We anneal the temperature to a sharp distribution at the end of training to gradually reduce the discrepancy between training and inference.\nThe number of modules in the MoE layer matches the number of domains we train on, since each module corresponds to one domain.\nHowever, we can increase the number of modules in a simple way by splitting each domain FF sublayer into multiple chunks.\nGiven  domains and an FF activation size of , we split each FF layer into  chunks with a dimension of .\nAs a result, the final MoE layer will have  modules.\nInstead of directly initializing MoE experts from domain experts in a one-to-one way, we also try including all domains in each MoE expert.\nThe motivation behind this is an observation that MoE experts trained in a standard way do not show domain specialization, but rather are activated uniformly across different domains (Jiang et al., 2024  ###reference_b21###).\nIn contrast, our domain experts are specialized to a specific domain through their training data.\nTo break this domain specialization, we split each domain expert‚Äôs FF layers into  chunks and then merge the -th chunks from all domains to build the -th MoE expert.\nThis way, each MoE expert contains the same amount of parameters from all domains."
        },
        {
            "section_id": "3.1",
            "parent_section_id": "3",
            "section_name": "Branch & Train: Embarrassingly Parallel Expert Training",
            "text": "Initializing from the seed model , we train  expert LLMs , with each model  being trained on the corresponding dataset  in the same manner as during pretraining, using the usual language modeling objective.\nSince each expert model  can be trained in complete separation from the others, the whole training process becomes -way embarrassingly parallel. This training paradigm has several benefits in large-scale distributed training. It allows linear scaling of overall training throughput when scaling up the size of compute, while joint training often faces uncertain performance from increasing batch size. It has lower all-to-all communication cost. It is also more resilient, as a single training failure will only affect one of the  training processes instead of halting the entire training.\nAfter all the expert training is finished, we will end up with  different LLMs, with each specializing in a specific distribution.\nAt this point, the Branch-Train-Merge method (Li et al., 2022a  ###reference_b27###; Gururangan et al., 2023  ###reference_b16###) uses these domain experts as is, choosing which expert to use by determining which domain the input belongs to at inference time.\nUsually multiple experts are chosen, and their final output distributions are simply averaged to generate the next token.\nOur BTX approach, in contrast, merges these domain experts back into a single LLM that is finetuned further, as we will describe in the next section."
        },
        {
            "section_id": "3.2",
            "parent_section_id": "3",
            "section_name": "MiX: Combining Separate Experts to be a Mixture-of-Experts",
            "text": "We employ a Mixture-of-Experts approach to combine the domain expert models .\nHowever, instead of using the classical procedure of mixing the final outputs from , we do a more fine-grained mixing by performing MoE within each layer of a Transformer.\nIn particular, we combine the different feedforward sublayers from the domain experts into a single MoE sublayer.\nIf  is the feedforward sublayer at the -th layer of the -th domain expert , then the combined MoE layer for input representation  at layer  will compute:\nHere  is a linear transformation and  is a routing function, which usually has sparse output and hence switches on only some experts.\nSince we can skip computing  if the corresponding router output is zero, the actual computation of  will be much more efficient than computing all domain experts.\nHowever, routing decisions can change from token to token, so one input sequence can employ all the domain expert FF layers if needed, even when only a few are accessed at any given token.\nIn our experiments, we use Top-k (k=2) routing where , unless otherwise stated.\nFor the self-attention sublayers, we combine the different domain experts by simply averaging their weights. The motivation behind this is the assumption that the self-attention layers are less domain specialized than the feedforward layers.\nWe do the same averaging for the remaining parameters (embeddings, etc.) as well.\nNote that the only new parameters we introduce are the router‚Äôs transformation parameters , which are negligible in size compared to the rest of the network.\nNevertheless, those new parameters need to be finetuned, so the router can make optimal decisions in selecting which domain  to use.\nIn addition, funetuning is helpful because the self-attention weights are constructed by averaging, and are likely not optimal.\nOverall, the entire system has not been optimized for working together at all in the embarrassingly parallel training framework, but our hypothesis is that even a small amount of combined finetuning might make large improvements."
        },
        {
            "section_id": "3.3",
            "parent_section_id": "3",
            "section_name": "Variations",
            "text": "We also experimented with several variations of our method.\nA common problem with MoE is the emergence of dead experts, which do not get activated by the router at all.\nCommon routing methods like Top-k are unlikely to escape from such a situation because a dead expert is never in the top-k selection, and therefore never receives a training signal.\nLoad balancing offers a simple solution by adding an extra loss term that encourages the experts to be utilized equally.\nWe use a loss term similar to (Fedus et al., 2022  ###reference_b13###  ###reference_b13###):\nHere  is the current data batch, and  is a hyperparameter. This loss is computed in each layer and added to the NLL loss.\nBesides Top-k routing, we also experiment with other routing methods:\nSwitch: It is a Top-1 routing method proposed by Fedus et al. (2022  ###reference_b13###  ###reference_b13###).\nSoft routing: We use softmax as the routing function , so all experts are activated both during training and inference. While it is likely to provide the best performance, it comes at the expense of increased compute.\nSample Top-1: We use the gumbel softmax (Jang et al., 2016  ###reference_b20###  ###reference_b20###) for .\nAt training time, we generate a soft sample from the gumbel softmax, but zero out all its values except the largest one. Then we compute only one expert corresponding to this largest value, omitting the other expert computations. At inference time, we simply do hard sampling. We anneal the temperature to a sharp distribution at the end of training to gradually reduce the discrepancy between training and inference.\nThe number of modules in the MoE layer matches the number of domains we train on, since each module corresponds to one domain.\nHowever, we can increase the number of modules in a simple way by splitting each domain FF sublayer into multiple chunks.\nGiven  domains and an FF activation size of , we split each FF layer into  chunks with a dimension of .\nAs a result, the final MoE layer will have  modules.\nInstead of directly initializing MoE experts from domain experts in a one-to-one way, we also try including all domains in each MoE expert.\nThe motivation behind this is an observation that MoE experts trained in a standard way do not show domain specialization, but rather are activated uniformly across different domains (Jiang et al., 2024  ###reference_b21###  ###reference_b21###).\nIn contrast, our domain experts are specialized to a specific domain through their training data.\nTo break this domain specialization, we split each domain expert‚Äôs FF layers into  chunks and then merge the -th chunks from all domains to build the -th MoE expert.\nThis way, each MoE expert contains the same amount of parameters from all domains."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Experiments",
            "text": "We first analyze how\nexpert LLMs specialize to specific domains. Results are summarized in Table 1  ###reference_###.\nAs expected, individual expert LLMs achieve the best performance in their respective domain, where the math and code domains see especially large improvements.\nIn addition, there are several interesting observations.\nWe see that the math expert training improved its code performance as well, indicating a close relation of these domains.\nHowever, such single-domain continued training also suffers from catastrophic forgetting with significant performance drops on some tasks in other domains. For example, the math and code expert are much worse on TriviaQA than the seed model.\nTable 2  ###reference_### and footnote 1  ###reference_te1### (right) show aggregated performance across multiple domains. More detailed per-task results are reported in Table 8  ###reference_### in the Appendix.\nCompared to the seed model Llama-2 7B, BTX models (both Sample Top-1 and Top-2 corresponding to different number of active parameters) improve on all expert domains, such as math, coding and world knowledge without regressing on other tasks such as commonsense reasoning.\nBTX with Top-2 experts (our default) also approaches the best performance of the specialized models Llemma 7B and CodeLlama 7B in the math and coding domains, while drastically improving over those models on domains that are not their speciality such as world knowledge and commonsense reasoning.\nCompared to alternative data-matching (DM) methods for continued pretraining such as dense and sparse upcycling, BTX achieves better performance on average with small gaps in the math and coding domains. BTX outperforms BTM by a large margin on average,\nindicating that MoE finetuning to learn token-level routing is beneficial. Overall, the results demonstrate that BTX is a more compute efficient method for continued pretraining which is robust to task interference from multi-task learning.\nBTX also outperforms\nLlama-2 13B on all tasks except\nreasoning, even though Llama-2 13B\nuses significantly more training compute and has slightly more active parameters.\n###table_1### We further compare BTX with the sparse upcycling baseline in the compute-matching (CM) scenario. Both train on the same data mixture during the MoE stage, but differ in terms of the percent of compute spent on MoE training.\nWhile sparse cycling performs close behind BTX, the parallel training of experts increases the training throughput of BTX, as is shown in Table 3  ###reference_###. As a result, BTX can train with more than  the data than pure MoE given the same training compute budget, and achieves slightly higher average performance across all domains.\n###table_2### Despite that the MoE training stage uses a fraction of the total training budget in pretraining (for example, Llama-2 pretraining uses 2T tokens), BTX brings steep improvements on general capabilities compared to alternative continued pretraining approaches such as multi-task learning of the dense model and Branch-Train-Merge.\nAs a special case of BTX, sparse upcycling without expert training outperforms dense and BTM but not BTX, given the same or larger compute budget.\nThe compute efficiency gains of BTX are from the embarrassingly parallel training of experts before MoE finetuning.\nIn terms of the active number of parameters (shown as circle sizes in 1  ###reference_te1### (left)), the MoE models are similar to the Llama-2 13B model. BTX uses less than half of the additional training compute compared to Llama-2 13B, but demonstrates improved performance on expert domains (math, code, and knowledge) and achieves better overall performance. This indicates that BTX‚Äôs training is more effective for the late stage of pretraining than using the same training protocol throughout the entire of pretraining."
        },
        {
            "section_id": "4.1",
            "parent_section_id": "4",
            "section_name": "Experimental Setup",
            "text": "We base our experiments on the setup used for Llama-2 pretraining (Touvron et al., 2023  ###reference_b37###).\nIn particular, we use the Llama-2 7B model as our seed model."
        },
        {
            "section_id": "4.1.1",
            "parent_section_id": "4.1",
            "section_name": "4.1.1 BTX Training",
            "text": "We use the pretrained Llama-2 (Touvron et al., 2023  ###reference_b37###) with 7B parameters as our seed model.\nAfter making three copies of the seed model Llama-2 7B, we continue training them on the following domain datasets to derive three domain experts:\nMath: The same data sources and mixture used in Llemma (Azerbayev et al., 2023  ###reference_b5###) model training. To be comparable to Llemma, we train on the same amount of data as well, i.e. 48k steps with 201B tokens in total.\nCode: The same data sources and mixture of code data used in CodeLlama pretraining (Rozi√®re et al., 2023  ###reference_b31###).\nThe code expert LLM is trained for 50k steps with 210B tokens in total to be comparable with the math expert.\nWikipedia: Wikipedia documents extracted between June to August 2022. The data was preprocessed to remove hyperlinks, comments and other formatting boilerplate. Since this is a smaller dataset, we train a total of 42B tokens.\nWhile we can proceed with only these three domain experts, we also include the original seed LLM as a ‚Äúgeneralist‚Äù expert so that its general knowledge is transferred to the final model.\nThus we mix these four expert models into a single MoE model as described in Section 3.2  ###reference_###.\nThen we finetune this MoE model on all the data sources used to train the four experts (including the original Llama-2 7B pretraining data for the generalist expert) and train for another 80B tokens.\nThe detailed sampling ratio across datasets in each domain as well as across the domains is described in Section 8  ###reference_###.\nFor BTX with default Top-2 routing, we use load balancing with , unless otherwise stated. For the Sample Top-1 routing, we use the temperature annealing schedule =max() from Jang et al. (2016  ###reference_b20###) with  where  is the number of training steps.\nFor the first layer only, we used soft-routing instead.\nSince the Sample Top-1 training is more efficient than Top-2, with the same compute budget it can train 160B tokens.\n###table_3###"
        },
        {
            "section_id": "4.1.2",
            "parent_section_id": "4.1",
            "section_name": "4.1.2 Baselines",
            "text": "We compare to the following baselines:  \nLlama-2: We compare to the original Llama-2 7B that we use as a seed model, as well as Llama-2 13B.  \nDense: Instead of training separate LLMs on different domain datasets, the dense baseline continues to train the seed LLM with all the data.  \nSparse upcycling:  \nThis baseline (Komatsuzaki et al., 2022  ###reference_b23###) initializes a MoE model from the seed model by making 4 identical copies of the feedforward module as experts. We use the Top-2 router with randomly initialized parameters. In addition to training a data matching baseline with the same data as is used in BTX and the dense baseline, we also train a sparse upcycling baseline with the same amount of GPU-days, i.e. compute-matching (CM), using the MoE finetuning data mixture throughout training. This is equivalent to a special case of BTX which does not contain embarrassingly parallel expert training.  \nBranch-Train-Merge (BTM): This baseline (Li et al., 2022a  ###reference_b27###) uses the same expert LLMs as BTX (including the original seed model) but uses them directly without building a MoE model. For a given context (input), it selects Top-k expert LLMs based on the similarity between the context and experts‚Äô training data. Following the efficient inference method used in Gururangan et al. (2023  ###reference_b16###), both context and experts‚Äô training data are embedded via tf-idf. Top-k experts are selected based on cosine similarity to the mean tf-idf embedding of each expert.  \nCodeLlama 7B: A language model specializing in code (Rozi√®re et al., 2023  ###reference_b31###) by continued training of the same seed model Llama-2 7B on code data. It also has other features such as long-context and infilling.  \nLlemma 7B: A language model specializing in mathematics (Azerbayev et al., 2023  ###reference_b5###) by continued training of CodeLlama 7B on math data.  \nWe use the same optimization hyperparameters for training of the baselines, expert models and MoE models. We use the AdamW optimizer with weight decay 0.1, and anneal the learning rate to the peak of with 100 steps of warmup, and decay to of the peak with a cosine schedule. We use a batch size of 4M tokens with a sequence length of 4096.  \n###table_4###"
        },
        {
            "section_id": "4.1.3",
            "parent_section_id": "4.1",
            "section_name": "4.1.3 Evaluation",
            "text": "For evaluation, we use the zero- and few-shot performance on multiple benchmarks that test different skills:\nMath: we report the average performance on GSM8K (8 shot) (Cobbe et al., 2021  ###reference_b10###) and MATH (4 shot) (Hendrycks et al., 2021b  ###reference_b18###) for math reasoning.\nCode: we report the average performance of HumanEval (0 shot) (Chen et al., 2021  ###reference_b8###) and MBPP (3 shot) (Austin et al., 2021  ###reference_b3###) for code generation.\nWorld knowledge: we report the average performance of Natural Questions (5 shot)(Kwiatkowski et al., 2019  ###reference_b24###) and TriviaQA (5 shot) (Joshi et al., 2017  ###reference_b22###).\nReasoning: we report the average 0-shot performance of ARC-Easy and ARC-Challenge (Clark et al., 2018  ###reference_b9###), SIQA (Sap et al., 2019  ###reference_b34###), PIQA (Bisk et al., 2020  ###reference_b6###) and WinoGrande (Sakaguchi et al., 2021  ###reference_b33###).\nGeneral: we report performance on MMLU (5 shot) (Hendrycks et al., 2021a  ###reference_b17###) which covers multiple domains.\n###figure_2### ###figure_3###"
        },
        {
            "section_id": "4.2",
            "parent_section_id": "4",
            "section_name": "Main Results",
            "text": "We first analyze how\nexpert LLMs specialize to specific domains. Results are summarized in Table 1  ###reference_###  ###reference_###.\nAs expected, individual expert LLMs achieve the best performance in their respective domain, where the math and code domains see especially large improvements.\nIn addition, there are several interesting observations.\nWe see that the math expert training improved its code performance as well, indicating a close relation of these domains.\nHowever, such single-domain continued training also suffers from catastrophic forgetting with significant performance drops on some tasks in other domains. For example, the math and code expert are much worse on TriviaQA than the seed model.\nTable 2  ###reference_###  ###reference_### and footnote 1  ###reference_te1###  ###reference_te1### (right) show aggregated performance across multiple domains. More detailed per-task results are reported in Table 8  ###reference_###  ###reference_### in the Appendix.\nCompared to the seed model Llama-2 7B, BTX models (both Sample Top-1 and Top-2 corresponding to different number of active parameters) improve on all expert domains, such as math, coding and world knowledge without regressing on other tasks such as commonsense reasoning.\nBTX with Top-2 experts (our default) also approaches the best performance of the specialized models Llemma 7B and CodeLlama 7B in the math and coding domains, while drastically improving over those models on domains that are not their speciality such as world knowledge and commonsense reasoning.\nCompared to alternative data-matching (DM) methods for continued pretraining such as dense and sparse upcycling, BTX achieves better performance on average with small gaps in the math and coding domains. BTX outperforms BTM by a large margin on average,\nindicating that MoE finetuning to learn token-level routing is beneficial. Overall, the results demonstrate that BTX is a more compute efficient method for continued pretraining which is robust to task interference from multi-task learning.\nBTX also outperforms\nLlama-2 13B on all tasks except\nreasoning, even though Llama-2 13B\nuses significantly more training compute and has slightly more active parameters.\n###table_5### We further compare BTX with the sparse upcycling baseline in the compute-matching (CM) scenario. Both train on the same data mixture during the MoE stage, but differ in terms of the percent of compute spent on MoE training.\nWhile sparse cycling performs close behind BTX, the parallel training of experts increases the training throughput of BTX, as is shown in Table 3  ###reference_###  ###reference_###. As a result, BTX can train with more than  the data than pure MoE given the same training compute budget, and achieves slightly higher average performance across all domains.\n###table_6### Despite that the MoE training stage uses a fraction of the total training budget in pretraining (for example, Llama-2 pretraining uses 2T tokens), BTX brings steep improvements on general capabilities compared to alternative continued pretraining approaches such as multi-task learning of the dense model and Branch-Train-Merge.\nAs a special case of BTX, sparse upcycling without expert training outperforms dense and BTM but not BTX, given the same or larger compute budget.\nThe compute efficiency gains of BTX are from the embarrassingly parallel training of experts before MoE finetuning.\nIn terms of the active number of parameters (shown as circle sizes in 1  ###reference_te1###  ###reference_te1### (left)), the MoE models are similar to the Llama-2 13B model. BTX uses less than half of the additional training compute compared to Llama-2 13B, but demonstrates improved performance on expert domains (math, code, and knowledge) and achieves better overall performance. This indicates that BTX‚Äôs training is more effective for the late stage of pretraining than using the same training protocol throughout the entire of pretraining."
        },
        {
            "section_id": "4.2.1",
            "parent_section_id": "4.2",
            "section_name": "4.2.1 Overall Performance",
            "text": "We first analyze how\nexpert LLMs specialize to specific domains. Results are summarized in Table 1  ###reference_###  ###reference_###  ###reference_###.\nAs expected, individual expert LLMs achieve the best performance in their respective domain, where the math and code domains see especially large improvements.\nIn addition, there are several interesting observations.\nWe see that the math expert training improved its code performance as well, indicating a close relation of these domains.\nHowever, such single-domain continued training also suffers from catastrophic forgetting with significant performance drops on some tasks in other domains. For example, the math and code expert are much worse on TriviaQA than the seed model.\nTable 2  ###reference_###  ###reference_###  ###reference_### and footnote 1  ###reference_te1###  ###reference_te1###  ###reference_te1### (right) show aggregated performance across multiple domains. More detailed per-task results are reported in Table 8  ###reference_###  ###reference_###  ###reference_### in the Appendix.\nCompared to the seed model Llama-2 7B, BTX models (both Sample Top-1 and Top-2 corresponding to different number of active parameters) improve on all expert domains, such as math, coding and world knowledge without regressing on other tasks such as commonsense reasoning.\nBTX with Top-2 experts (our default) also approaches the best performance of the specialized models Llemma 7B and CodeLlama 7B in the math and coding domains, while drastically improving over those models on domains that are not their speciality such as world knowledge and commonsense reasoning.\nCompared to alternative data-matching (DM) methods for continued pretraining such as dense and sparse upcycling, BTX achieves better performance on average with small gaps in the math and coding domains. BTX outperforms BTM by a large margin on average,\nindicating that MoE finetuning to learn token-level routing is beneficial. Overall, the results demonstrate that BTX is a more compute efficient method for continued pretraining which is robust to task interference from multi-task learning.\nBTX also outperforms\nLlama-2 13B on all tasks except\nreasoning, even though Llama-2 13B\nuses significantly more training compute and has slightly more active parameters.\n###table_7### We further compare BTX with the sparse upcycling baseline in the compute-matching (CM) scenario. Both train on the same data mixture during the MoE stage, but differ in terms of the percent of compute spent on MoE training.\nWhile sparse cycling performs close behind BTX, the parallel training of experts increases the training throughput of BTX, as is shown in Table 3  ###reference_###  ###reference_###  ###reference_###. As a result, BTX can train with more than  the data than pure MoE given the same training compute budget, and achieves slightly higher average performance across all domains.\n###table_8###"
        },
        {
            "section_id": "4.2.2",
            "parent_section_id": "4.2",
            "section_name": "4.2.2 Better compute-performance tradeoff",
            "text": "We compare BTX with baselines in terms of compute efficiency in footnote 1  ###reference_te1### (left). The X-axis shows the total training compute starting from the seed model measured in GPU days, which includes the domain expert training and finetuning of the MoE model. The Y-axis measures the overall performance reported in Table 2  ###reference_###.\nDespite that the MoE training stage uses a fraction of the total training budget in pretraining (for example, Llama-2 pretraining uses 2T tokens), BTX brings steep improvements on general capabilities compared to alternative continued pretraining approaches such as multi-task learning of the dense model and Branch-Train-Merge.\nAs a special case of BTX, sparse upcycling without expert training outperforms dense and BTM but not BTX, given the same or larger compute budget.\nThe compute efficiency gains of BTX are from the embarrassingly parallel training of experts before MoE finetuning.\nIn terms of the active number of parameters (shown as circle sizes in 1  ###reference_te1###  ###reference_te1###  ###reference_te1### (left)), the MoE models are similar to the Llama-2 13B model. BTX uses less than half of the additional training compute compared to Llama-2 13B, but demonstrates improved performance on expert domains (math, code, and knowledge) and achieves better overall performance. This indicates that BTX‚Äôs training is more effective for the late stage of pretraining than using the same training protocol throughout the entire of pretraining."
        },
        {
            "section_id": "4.3",
            "parent_section_id": "4",
            "section_name": "Ablations & Analysis",
            "text": ""
        },
        {
            "section_id": "4.3.1",
            "parent_section_id": "4.3",
            "section_name": "4.3.1 Ablations of BTX training",
            "text": "First, we compare the different routing methods with varying amount of active parameters for different amounts of finetuning. For fair comparison, load balancing is not used in any of them.\nResults are shown in Table 4  ###reference_###.\nFor Switch routing, we set its capacity factor to 1.5 (a hard limit after which routed tokens will be dropped). We found the Switch router to be subpar in average performance.\nThe soft routing performs the best, but that is expected since it lacks sparsity and has the highest number of active parameters.\nOverall, the Top-2 routing gives us a good balance between performance and efficiency.\nWe also ablate additional design choices of BTX, with results summarized in Table 5  ###reference_###.\nWe found that MoE training without load balancing performs worse on the coding task (HumanEval), but has higher math (GSM8k) accuracy.\nThe routing analysis in the next section will give more insight into this trade-off.\nNext, freezing the feedforward modules initialized from each expert, and only training the rest of the MoE model has little impact on performance across all tasks.\nThis suggests that individual experts already gained sufficient domain knowledge during the branch-train stage, while the mix (MoE finetuning) stage mainly trains the other parameters such as averaged weights in the self-attention and the router transformations .\nWe also test our blending and splitting techniques described in Section 3.3  ###reference_###.\nThe performance across all tasks dropped when experts are mixed, suggesting that domain FF layers cannot be mixed in this way.\nSplitting each domain FF into  chunks to obtain 8 modules in the MoE layer also does not improve performance, even if Top-4 routing is used to match the active number of parameters.\n###figure_4### ###figure_5###"
        },
        {
            "section_id": "4.3.2",
            "parent_section_id": "4.3",
            "section_name": "4.3.2 Routing Analysis",
            "text": "To gain an in-depth understanding of the performance of BTX, we run model evaluations on downstream tasks and examine the routing decisions among the experts. The results are summarized in Figure 3  ###reference_###, and we also report detailed ablation results for different BTX setups in Section 10  ###reference_###. Compared to other routing methods, Top-2 routing with load balancing ensures a more uniform distribution of the load between experts. Analyzing the token probability distributions, we observe a shift towards low probability scores across all experts with load balancing, especially closer to the final layers of the model, which contributes to the fair routing. Interestingly, all models without load balance heavily rely on the Math expert, with a low overall contribution from other experts, especially the Code expert. A dead Code expert comes ‚Äúback to life‚Äù with load balancing introduced in training. In fact, it not only becomes visible, but becomes the dominant expert in the math and code domains.\nExamples of the routing decisions for Top-2 with load balancing can be found in the Table 6  ###reference_###. Overall across math domain tasks, tokens are often routed to the Code and Llama-2 7B experts. If we look at a more detailed token distribution (Section 10  ###reference_###, Figure 6  ###reference_###), we find that the GSM8K task prefers Code and Llama-2 experts, while the MATH task relies more on the in-domain Math expert. We hypothesise that this happens because the GSM8K dataset consists of grade school math problems that require common sense knowledge and basic arithmetic operations.\nBoth the Code and World knowledge tasks mostly route to the in-domain Code and Wikipedia experts respectively.\nAs observed earlier in Section 4.3.1  ###reference_.SSS1###, when load balancing is introduced, there are improvements in coding tasks but degradation in math tasks, which can be explained with these changes in domain expert routing. The reasoning tasks in contrast exhibit similar behaviour, and rely equally on Math and generalist LLM‚Äôs expertise."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Conclusion",
            "text": "We introduced Branch-Train-MiX (BTX), a simple continued pretraining method to improve an LLM‚Äôs capabilities. It trains multiple copies of a seed LLM to specialize in multiple domains in an asynchronous and parallel fashion and later merges them back into a single Mixture-of-Experts (MoE) model via finetuning.\nWhile the initial parallel training stage brings higher training throughput and scalability, the second MoE finetuning stage makes the final LLM more performant.\nOur experiments suggest that a generalist LLM‚Äôs performance can be boosted by continued training on datasets with specialized knowledge and skills using our method. We find that the BTX approach is more compute efficient than training a larger generalist LLM or several separately specialized LLMs. These insights can inform how to allocate compute in late pretraining to achieve a strong generalist model."
        },
        {
            "section_id": "6",
            "parent_section_id": null,
            "section_name": "Limitations & Future Work",
            "text": "Although our experimental results on BTX are promising, we have not fully explored its potential in this paper.\nDue to compute limitations, we only experimented with three domains and four experts in this paper.\nTraining on more domains such as using unsupervised domain discovery (Gururangan et al., 2023  ###reference_b16###) should amplify the benefit of the parallelization of experts training.\nHaving more experts will also make the final MoE model more efficient because the number of active experts can remain the same while its overall capacity increases.\nIn our experiments, we used a simple implementation of MoE and did not optimize it using more complex techniques such as placing different experts on different GPUs to run them in parallel.\nSuch an efficient MoE implementation could shorten the training time of BTX, and the sparse upcycling baseline as well.\nCompared to BTM, BTX provides an approach to finetune the combined experts, which can be directly applied in instruction finetuning or RLHF procedures.\nHowever, we leave that for future work as we focused on the pretraining stage in this paper.\nThe question of whether experts in MoE are better off specializing in specific domains or not is an interesting one that is worth further investigation.\nOur approach explicitly tied experts to certain domains, but such specialization does not seem to emerge naturally during MoE training (Jiang et al., 2024  ###reference_b21###).\nWe observed that some experts are used more in their corresponding domain tasks, showing that their domain specialization partially remains even after the MoE finetuning.\nWe only compared BTX to two of its special variants, i.e. BTM with 100% compute allocated to expert training and 0% on MoE finetuning, and sparse upcycling with 0% compute allocated to expert training and 100% on MoE finetuning. Future work could perform a thorough sweep of the compute allocation ratio between expert training and MoE training. Also, we did not perform experiments with different data mixtures for MoE finetuning other than uniform sampling."
        },
        {
            "section_id": "7",
            "parent_section_id": null,
            "section_name": "Acknowledgements",
            "text": "We thank Margaret Li, Kushal Tirumala, Luke Zettlemoyer, Artidoro Pagnoni, Suchin Gururangan, Mike Lewis and Emily Dinan for their discussion and feedback, and Andrew Cohen and Arun Babu for their help with the training implementation."
        },
        {
            "section_id": "8",
            "parent_section_id": null,
            "section_name": "Data mixture",
            "text": "Table 7  ###reference_### shows the exact data mixture ratios used in training each domain expert.\nFor finetuning the MoE model, we sample datasets that used to train math expert, code expert, wikipedia expert and the original Llama-2 7B with probabilities 30.16%, 40.31%, 10.30% and 19.23%.\n###table_9###"
        },
        {
            "section_id": "9",
            "parent_section_id": null,
            "section_name": "Evaluation",
            "text": "We use the same evaluation metrics as is used in Touvron et al. (2023  ###reference_b37###) and Rozi√®re et al. (2023  ###reference_b31###): for code tasks (HumanEval and MBPP) we report pass@1, for math tasks (GSM8k and MATH) and knowledge tasks (Natural Questions and TriviaQA) we report exact match, we report accuracy for MMLU and ARC. We use greedy decoding for all generations. Detailed results on all tasks are reported in Table 8  ###reference_###.\n###table_10###"
        }
    ]
}