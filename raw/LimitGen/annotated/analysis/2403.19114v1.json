{
    "title": "Top Leaderboard Ranking = Top Coding Proficiency, Always? \\scalerel*○ EvoEval: Evolving Coding Benchmarks via LLM",
    "abstract": "LLMs have become the go-to choice for code generation tasks, with an exponential increase in the training, development, and usage of LLMs specifically for code generation.\nTo evaluate the ability of LLMs on code, both academic and industry practitioners rely on popular handcrafted benchmarks.\nHowever, prior benchmarks contain only a very limited set of problems, both in quantity and variety.\nFurther, due to popularity and age, many benchmarks are prone to data leakage where example solutions can be readily found on the web and thus potentially in training data.\nSuch limitations inevitably lead us to inquire:\nIs the leaderboard performance on existing benchmarks reliable and comprehensive enough to measure the program synthesis ability of LLMs?\nTo address this, we introduce \\scalerel*○ EvoEval– a program synthesis benchmark suite created by evolving existing benchmarks into different targeted domains for a comprehensive evaluation of LLM coding abilities.\nOur study on 51 LLMs shows that compared to the high performance obtained on standard benchmarks like HumanEval, there is a significant drop in performance (on average 39.4%) when using EvoEval.\nAdditionally, the decrease in performance can range from 19.6% to 47.7%, leading to drastic ranking changes amongst LLMs and showing potential overfitting of existing benchmarks.\nFurthermore, we showcase various insights, including the brittleness of instruction-following models when encountering rewording or subtle changes as well as the importance of learning problem composition and decomposition.\nEvoEval not only provides comprehensive benchmarks, but can be used to further evolve arbitrary problems to keep up with advances and the ever-changing landscape of LLMs for code.\nWe have open-sourced our benchmarks, tools, and complete LLM generations at https://github.com/evo-eval/evoeval",
    "sections": [
        {
            "section_id": "1",
            "parent_section_id": null,
            "section_name": "Introduction",
            "text": "Program synthesis [15  ###reference_b15###] is widely regarded as the holy-grail in the field of computer science.\nRecently, large language models (LLMs) have become the default choice for program synthesis due to its code reasoning capabilities acquired through training on large amounts of open-source code repositories.\nPopular LLMs like GPT-4 [36  ###reference_b36###], Claude-3 [3  ###reference_b3###], and Gemini [43  ###reference_b43###] have shown tremendous success in aiding developers on a wide-range of coding tasks such as code completion [10  ###reference_b10###], repair [51  ###reference_b51###], and test generation [12  ###reference_b12###].\nFurthermore, researchers and industry practitioners have designed code LLMs (e.g., DeepSeeker Coder [16  ###reference_b16###], CodeLlama [40  ###reference_b40###], and StarCoder [26  ###reference_b26###]) using a variety of training methods designed specifically for the code domain to improve LLM code understanding.\nIn order to evaluate the coding abilities of LLMs, benchmarks like HumanEval [10  ###reference_b10###] and MBPP [4  ###reference_b4###] have been handcrafted to evaluate the program synthesis task of turning natural language descriptions (e.g., docstrings) into code snippets.\nThese code benchmarks measure functional correctness by evaluating LLM-generated solutions against a set of limited predefined tests.\nRecent work [28  ###reference_b28###] has further improved these benchmarks with augmented tests to rigorously evaluate the functional correctness of LLM generated code.\nHowever, apart from test inadequacy, existing popular code synthesis benchmarks have the following limitations:\nLimited amount and variety of problems.\nCode benchmarks are mainly constructed by human annotators manually.\nDue to the high manual effort required, they only contain a limited amount of problems.\nFor example, HumanEval [10  ###reference_b10###] only contains 164 handcrafted problems.\nSuch a low amount of problems is not sufficient to fully measure the complete spectrum of program synthesis capability of state-of-the-art LLMs.\nAdditionally, these code benchmarks include mostly self-contained coding problems that lack variety in both problem types and domains, where the final evaluation output only shows the percentage of problems solved.\nWhile they provide a baseline overview of the coding abilities,\nLLM builders and users cannot gain deeper insights to exactly what problem types or coding scenarios the particular LLM may excel or struggle in.\nProne to data leakage and training dataset composition. Popular benchmarks like HumanEval and MBPP were released almost 4 years ago, with example solutions available in third-party open-source repositories.\nWhile recent LLMs have been taking turns climbing the leaderboard by achieving higher pass@ scores (often with less than 1 percent difference between the next best model), just how much of that is attributed to having leaked solutions as part of the training data?\nFurthermore, the problems within these benchmarks are often simple derivatives of common coding problems/concepts.\nIn fact, recent work [39  ###reference_b39###] has shown that there are substantial overlap between benchmark solutions and open-source training corpuses.\nIn addition, closed-source LLMs may even deliberately include benchmark groundtruths to artificially boost their leaderboard status [7  ###reference_b7###].\nAs such, it is unclear whether high scores achieved by LLMs are truly due to their learnt coding capability or instead obtained via memorizing benchmark solutions.\nAs more LLMs are being constructed, trained, and used especially for code, the insufficient evaluation benchmarks raise the question of validity:\nIs leaderboard performance on existing benchmarks reliable and comprehensive enough to measure the program synthesis ability of LLMs?\n###figure_1### Our work. To address the limitation of existing benchmarks,\nwe introduce \\scalerel*○ EvoEval 111coincidentally similar pronunciation with EvilEval – a set of program synthesis benchmarks created by evolving existing problems.\nThe key idea behind EvoEval is to use LLMs instead of humans to produce new code synthesis problems based on a variety of different instructions aimed at evolving or transforming the existing benchmark problems into targeted domains\nfor more comprehensive evaluation.\nDifferent from prior benchmark constructions that either obtain problems from open-source repositories or databases – leading to data leakage or require manual construction of each problem – resulting in high manual effort and limited diversity, EvoEval directly uses LLMs with targeted transformation prompts to synthesis new coding problems.\nSpecifically, we design 5 different targeted transformation prompts: Difficult, Creative, Subtle, Combine and Tool Use.\nWe then prompt GPT-4 to independently transform any existing problem in previous benchmarks into a new problem in the targeted domain.\n###figure_2### Figure 1  ###reference_### shows a concrete example of EvoEval in action starting with an initial problem in HumanEval–\nvowel_counts to count the number of vowels in the string.\n\n1\n We first observe the transformation to a more difficult problem by asking GPT-4 to add additional constraints or requirements.\nThis new problem contains a separate custom vowel list that makes the overall program logic more complex.\n\n2\n We can also transform to a more creative problem of create_alias that still uses concepts like vowels and consonants but involves a much more creative and unusual problem description.\n\n3\n We can also make subtle changes to the problem where we only count the lowercase vowels to test if the LLM is simply memorizing the benchmark.\n\n4\n We can additionally combine concepts from multiple problems together.\nIn the example, we use another problem bf to create a new problem that returns the vowels in each planet sorted based on the orbiting order.\n\n5\n Furthermore, we can test the ability for LLMs to utilize auxiliary helper functions (common place in real-world code repositories) to solve more complex problems.\nAgain we reuse the concepts of vowels from the initial problem, where the frequency of each vowel should be computed. However instead of directly solving the problem, the LLM can directly use the provided check_vowel helper function to simplify the solution.\nTogether, each of these transformed benchmarks are designed to introduce more difficult and complex problems as well as test different aspects of the LLM code understanding and synthesis ability.\nIn EvoEval, we additionally use GPT-4 to generate the groundtruth solution to each problem as well as rigorous test cases to ensure we can evaluate the functional correctness of LLM-synthesized code on EvoEval.\nFinally, we manually check each generated problem and corresponding groundtruth to ensure problem clarity and correctness.\nEvoEval serves as a way to further evolve existing benchmarks into more complex and well-suited problems for evaluation in order to keep up with the ever-growing LLM research.\nContribution. Our work proposes to evolve existing problems for benchmark creation:\nBenchmark: We present EvoEval– a set of program synthesis benchmarks created by evolving existing popular HumanEval coding benchmark problems.\nEvoEval includes 828 problems across 5 semantic-altering and 2 semantic-preserving benchmarks.\nFurthermore, EvoEval also includes additional benchmarks to study program synthesis concepts like problem composition and decomposition. EvoEval is fully complete with groundtruth implementations and robust testcases to evaluate functional correctness.\nApproach: We propose a complete pipeline to directly synthesize new coding problems for benchmarking by evolving existing problems through the use of targeted transformation prompts.\nOur pipeline aims to reduce manual checking effort using a self-consistency approach to automatically refine any problem inconsistencies and generate groundtruth as well as test cases.\nOur approach is general and can be used on other benchmark problems, adopted for transformation into additional domains or utilize different problem generation strategies [50  ###reference_b50###].\nStudy: We conduct a comprehensive study on 51 different LLMs across all benchmarks in EvoEval.\nWe found that compared to the high performance obtained on standard benchmarks like HumanEval, when evaluated on EvoEval, popular LLMs significantly drop in performance (on average 39.4%).\nAdditionally, this drop is not uniform across all LLMs and can range from 19.6% to 47.7%, leading to drastic ranking changes amongst top performing models.\nWe further demonstrate that certain LLMs cannot keep up their high performance obtained in HumanEval when evaluated on more challenging or problems in different domains, highlighting the possibilities of overfitting to existing benchmarks.\nMoreover, we observe that while instruction-following LLMs perform well in solving self-contained problems, they struggle with the tool using aspect of utilizing already provided auxiliary functions.\nFurthermore, they are particularly sensitive to the problem description where rephrasing or subtle changes to the problem docstring leads to degradation in output solutions compared to their base non-instruction-following counterparts.\nAdditionally, we demonstrate that current state-of-the-art LLMs fail to effectively compose multiple general coding concepts to solve more complex variants, or address subproblems decomposed from previously solved difficult problem."
        },
        {
            "section_id": "2",
            "parent_section_id": null,
            "section_name": "Approach",
            "text": "###figure_3### Figure 2  ###reference_### shows the overview of the benchmark creation pipeline for EvoEval.\nWe start by taking the original problem and apply a chosen targeted transformation prompt aimed at prompting GPT-4 to produce a new code synthesis problem along the targeted domain.\nUsing this initial transformed problem, we enter our refinement pipeline to fix any ambiguities or inconsistencies in the problem description, as well as generating the test cases and groundtruth solution for functional evaluation.\nFinally, to ensure correctness, we manually examine each produced problem along with the groundtruth and make corresponding changes to produce the final evolved benchmarks.\nTargeted problem transformation.\nEvoEval uses zero-shot prompting to evolve an existing coding benchmark to produce new and diverse problems.\nEach transformation prompt, as shown in the examples in Figure 1  ###reference_###, aims to transform the existing problem in a specific manner.\nIn particular, we define two different types of transformation prompts: 1) semantic-altering – change the semantic meaning of the original problem and 2) semantic-preserving – modify the problem description while keeping the semantic meaning the same.\nWhile Figure 1  ###reference_### shows only semantic-altering transformation prompts to produce new problems, we can also produce semantic-preserving problems to test additional aspect of the LLM coding abilities.\nProblem refinement & groundtruth Generation.\nThe initial evolved problem produced by GPT-4 may include small inconsistencies such as contradicting sentences or incorrect I/O examples in the docstring.\nFor coding benchmarks, such inconsistencies are especially damaging as it can detract from the problem specification, leading to inaccurate evaluation of LLM coding capabilities.\nAs such, we introduce a refinement pipeline to iteratively rephrase and refine problem as needed.\nIn addition, during this process, we also use GPT-4 to produce the necessary groundtruth implementation of the function as well as example test cases to be used for evaluation.\nWe first directly use GPT-4 to obtain a possible solution for the initial problem.\nAdditionally, we also prompt GPT-4 to extract (if available in the initial problem docstring) or produce the test inputs for the transformed problem.\nWe then evaluate the test inputs on the solution to derive the corresponding expected test outputs.\nNext, using these test inputs/outputs, we instruct GPT-4 to add or fix the example test cases in the docstring, providing further demonstrations of the task.\nUsing this refined problem, we again generate a solution.\nWe then leverage self-consistency [47  ###reference_b47###] to check if the new solution on the test inputs produce the same outputs as the previous solution.\nThe intuition is that since both solutions are generated by GPT-4 and the refined problem should only include minimal changes (e.g., adding new testcase examples), the solution output should then be the same in the absence of any potential inconsistencies or ambiguity in problem description.\nAs such, if we observe differences between the two solution outputs, we ask GPT-4 to further rephrase and fix any inconsistencies in the original problem and repeat the process.\nOn the other hand, if both solutions agree on outputs, we terminate the problem refinement stage and return the trio comprising of the new problem description, the solution as the groundtruth and the test cases for functional evaluation.\nManual examination & test augmentation.\nFor each transformed problem, we carefully examine and adjust any final faults to ensure each problem and groundtruth is correctly specified and implemented.\nAdditionally, using the initial set of test cases from the refinement stage, we further generate additional tests following the LLM-based test augmentation technique in EvalPlus [28  ###reference_b28###].\nFinally, we produce EvoEval, a comprehensive code synthesis benchmark suite, which through the use of evolving transformations can generate diverse coding problems to evaluate LLM coding capability across various problem domains."
        },
        {
            "section_id": "3",
            "parent_section_id": null,
            "section_name": "EvoEval Dataset Overview",
            "text": "###table_1### ###figure_4### ###figure_5### ###figure_6### We use the problems in HumanEval as seeds to produce EvoEval.\nProblems in EvoEval consist mainly of self-contained functions,\nexcept for Tool_Use that includes helper functions specifically designed to test the tool using capability of LLMs.\nEach problem uses a docstring to illustrate the problem specification, along with test cases and groundtruth to evaluate the functional correctness.\nTable 1  ###reference_### shows the statistics of the benchmarks in EvoEval.\nIn total, EvoEval includes 828 problems across 7 different datasets (5 semantic-altering and 2 semantic-preserving):\nDifficult: Introduce complexity by adding additional constraints and requirements, replace commonly used requirements to less common ones, or add additional reasoning steps to the original problem.\nCreative: Generate a more creative problem compared to the original through the use of stories or uncommon narratives.\nSubtle: Make a subtle and minor change to the original problem such as inverting or replacing a requirement.\nCombine: Combine two different problems by integrating the concepts from both problems. In order to select problems that make sense to combine, we apply a simple heuristic to combine only problems of the same type together categorized based on the type of input arguments in the original problem.\nTool_Use: Produce a new problem containing a main problem and one or more helpers functions which can be used to solve it.\nEach helper function is fully implemented and provides hints or useful functionality for solving the main problem. The main problem does not explicitly reference individual helper functions, and we do not require the model to use the provided helpers.\nVerbose: Reword the original docstring to be more verbose. These verbose docstrings can use more descriptive language to illustrate the problem, include detailed explanation of the example output, and provide additional hints.\nConcise: Reword the original docstring to be more concise by removing unnecessary details and using concise language.\nFurthermore, simple examples that are not required to demonstrate edge cases may be removed.\nFor each of the semantic-altering benchmarks, we generate 100 problems each using different seed problems from HumanEval.\nFor semantic-preserving benchmarks, we generate using all 164 problems in HumanEval as it requires less validation since we can reuse the original groundtruths.\nAs shown in Table 1  ###reference_###, compared to HumanEval, EvoEval contains longer coding questions with longer average problem length.\nFurthermore, EvoEval also uses more test cases to perform robust evaluation compared to base HumanEval.\nFigure 3  ###reference_### shows the embedding visualization using t-SNE [18  ###reference_b18###]222perplexity=50 and iter=1000 using text-embedding-3-large model from OpenAI\nby projecting high-dimension representation of the problems docstrings in both EvoEval and HumanEval into the 2D plane.\nFirst, we see that Creative and Tool_Use drastically change the embedding distribution compared to the original dataset.\nThe arrow in Figure 3(a)  ###reference_sf1### shows one example of the shift in distribution from the original problem to a creative one.\nNext, we see that Subtle, Difficult and Combine largely retain the same distribution as the original problems.\nThis is due to the high parity across these problem descriptions where Subtle only applies subtle changes and Difficult adds additional complex constraints while keeping the main problem descriptions largely the same.\nSpecifically, for Combine, we can see from an example arrow in Figure 3(b)  ###reference_sf2###, the new combined problem shifts the embedding for both of the original problems.\nFinally, we observe that for Verbose and Concise, the embeddings almost perfectly match the original problem, reflecting their semantic-preserving nature.\nIn Appendix C  ###reference_###, we present example problems for each benchmark in EvoEval."
        },
        {
            "section_id": "4",
            "parent_section_id": null,
            "section_name": "Methodology",
            "text": "Setup.\nEach LLM generated sample is executed against the test cases in EvoEval and evaluated using differential testing [31  ###reference_b31###] – comparing against the groundtruth results to measure functional correctness.\nWe report the functional correctness by using the popular pass@ metric.\nWe focus on greedy decoding (i.e., producing a deterministic sample per each problem with temperature = 0).\nWe denote this as pass@.\nModels. We evaluate 51 popular state-of-the-art LLMs, including both proprietary and open-source models on EvoEval.\nWe evaluate not only the popular general-purpose LLMs but also include recent code-based LLMs for comprehensive evaluation.\nFurther, we classify the LLMs as either base or instruction-following and focus our analysis on discussing the effect of model variants have on EvoEval performance.\nInput format. To produce the code solution using each LLM, we provide a specific input prompt: For base LLMs (i.e., not instruction-tuned variants), we simply use only the function header with the docstring and let the LLM autocomplete the solution.\nFor instruction-following LLMs, we follow the model-makers’ guide on the exact instruction and format to use and ask the LLM to generate a complete solution for the problem."
        },
        {
            "section_id": "5",
            "parent_section_id": null,
            "section_name": "Evaluation",
            "text": "###figure_7### ###table_2### ###figure_8### ###figure_9### ###figure_10### ###figure_11### ###figure_12### ###figure_13### ###figure_14### ###figure_15### ###figure_16### ###figure_17### ###figure_18### ###figure_19### *C\n###figure_20### ###figure_21### *C\n###figure_22### ###figure_23### *C\n###figure_24### ###figure_25### ###figure_26### ###figure_27### ###figure_28### ###figure_29### ###figure_30### ###figure_31### ###figure_32### *C\n###figure_33### ###figure_34### *C\n###figure_35### ###figure_36### ###figure_37### ###figure_38### ###figure_39### ###figure_40### ###figure_41### ###figure_42### ###figure_43### ###figure_44### ###figure_45### *C\n###figure_46### ###figure_47### *C\n###figure_48### ###figure_49### *C\n###figure_50### ###figure_51### *C\n###figure_52### ###figure_53### ###figure_54### ###figure_55### ###figure_56### *C\n###figure_57### ###figure_58### ###figure_59###"
        },
        {
            "section_id": "5.2",
            "parent_section_id": "5",
            "section_name": "Problem Composition",
            "text": "###table_3### ###figure_66### ###figure_67### ###figure_68### ###figure_69### *C\n###figure_70### ###figure_71### ###figure_72### ###figure_73### *C\n###figure_74### ###figure_75### *C\n###figure_76### ###figure_77### *C\n###figure_78### ###figure_79### ###figure_80### ###figure_81### ###figure_82### ###figure_83### ###figure_84### ###figure_85### *C\n###figure_86### ###figure_87### ###figure_88### ###figure_89### *C\n###figure_90### ###figure_91### *C\n###figure_92### ###figure_93### *C\n###figure_94### ###figure_95### ###figure_96### ###figure_97### Composition problems.\nThe ability to compose different known concepts to solve new problems is known as compositional generalization [24  ###reference_b24###].\nThis skill is essential for code synthesis, especially for complex problems in real-world programs.\nHowever, measuring compositional generalization in LLM presents a fundamental challenge since it requires controlling the relationship between training and test distributions [41  ###reference_b41###].\nWhile it is not easy to control the pre-training data of LLMs, we have more control in the testing phase.\nHence, we focus on program concepts that have been demonstrated to fall within the capabilities of an LLM, and explore whether this proficiency extends to the combination of program concepts.\nAs such, we start by taking a deeper look at the Combine problems evolved from combining previous HumanEval problems.\nFirst half of Table 3  ###reference_### shows the detailed breakdown of the Combine dataset results on the top 8 performing LLMs.\nWe observe that almost all problems solved in Combine came from the pass both category, which is intuitive as we do not expect LLMs to solve a problem composed of subproblems that it cannot already solve.\nHowever, we see that overall, the composition percentage is quite low as only GPT-4 is able achieve greater than half.This demonstrates, for the first time, that while state-of-the-art LLMs can achieve a high pass rate on simple programming tasks in general-purpose languages like Python, they still struggle with generalizing and composing these known concepts to address more complex problems.\n###figure_98### Naive combination problems. Since Combine problems are not guaranteed to not contain additional new logic or concepts, we build a simplified dataset for sequential composition.\nLet  and  be two separate problems with  as input(s) for , we aim to create a new problem  with same inputs where the solution can be written as .\nTo accomplish this, the new problem includes a sequential docstring by attaching the docstring of problem  followed by .\nDirectly concatenating them will lead to unclear descriptions, as such, for each problem in HumanEval, we manually create two separate variants based on which order the problem may come in the new docstring.\nFigure 8  ###reference_### shows an example naive combination problem with the manual sequential instruction highlighted in red.\nUsing these modified problem docstrings, we build a sequential combination dataset – Combine-naive, containing 1074 problems by randomly combining problems filtering for input output matching (i.e., type of  should equal to type of  in )\nThe latter half of Table 3  ###reference_### shows the results on Combine-naive following the same setup as Combine.\nWe observe that while the composition percentage on the naive dataset improves significantly compared to the evolved Combine dataset, it still fails to reach near perfection, with the best LLM being able to only solve 3/4 of prior pass both problems.\nWhile existing training or inference paradigms for LLMs for code focus on obtaining high quality datasets boosted with instruction-tuning,\nour result shows that existing LLMs still struggle with the concept of problem composition to tackle more complex problems.\nWe hope future research can design novel training methods to tackle this limitation."
        },
        {
            "section_id": "5.3",
            "parent_section_id": "5",
            "section_name": "Problem Decomposition",
            "text": "###table_4### ###figure_99### ###figure_100### ###figure_101### ###figure_102### *C\n###figure_103### ###figure_104### ###figure_105### ###figure_106### *C\n###figure_107### ###figure_108### *C\n###figure_109### ###figure_110### *C\n###figure_111### ###figure_112### ###figure_113### ###figure_114### Given our analysis and benchmark on combining different problems together, a nature follow-up would be to look at problem decomposition – decomposing larger problems into multiple subproblems.\nWe start by selecting 50 HumanEval problems and then follow our approach in Section 2  ###reference_### to decompose each original problem into two smaller subproblems, creating 100 problems in our Decompose benchmark.\nTable 4  ###reference_### shows the results of selected LLMs on Decompose (the same set of LLMs as Combine).\nWe first observe that similar to the composition percentage in the Combine and Combine-naive problems, LLMs do not achieve a high decomposition percentage.\nOne possible interpretation is that current LLMs are trained to memorize or recover seen outputs in their training data, and when used for program synthesis, they cannot generalize the concepts from training data.\nThis is demonstrated by not being able to solve smaller subproblems obtained from solved more difficult parent problems.\nOn the other hand, we show that LLMs can sometimes solve both smaller subproblems even when the original parent problem is not solved (i.e., recomposition percentage).\nDecompose is akin to breaking the harder problem down into easier subproblems, which is related to planning in prior work [22  ###reference_b22###].\nWe hope future work can again build on these insights to achieve the best of both worlds in being able to succcesfully generalize difficult concepts into subproblems and adopting decomposing/planning to solve additional challenging problems."
        },
        {
            "section_id": "5.4",
            "parent_section_id": "5",
            "section_name": "Tool Using",
            "text": "###figure_115### We further analyze the Tool_Use dataset, which contains pre-defined helper or auxiliary functions in addition to the main synthesis problem.\nAdditionally, we construct Tool_Use-Main_Only dataset, which contains the same set of problem as Tool_Use, except that the input to the LLM consists only of the main problem description without including any helpers.\nUsing both datasets together, we can evaluate the ability of LLMs to use helper functions to solve more complex problem.\nWe observe that compared to scenarios without any helper functions (average pass@ of 28.6%), LLMs on average improve by 81.3% when provided with the helper functions.\nThis is to be expected as the helper functions provides additional utilities in aiding to solve the more complex problem.\nHowever, this improvement is not uniform, as we see that the average improvement when given the auxiliary functions for instruction-following models is only 60.4% compared to the non-instruction-following LLMs’ improvement of 122.0%.\nFigure 9  ###reference_### show the detailed comparison between 10 instruction-following and their base LLMs on both the Tool_Use-Main_Only and Tool_Use dataset.\nWe observe that without the helpers, the instruction-following models significantly outperform their base LLMs.\nHowever, once the helpers are provided, this gap is drastically decreased, with cases even where the base models outperform their instruction-following counterparts.\nAs real-world coding involves understanding, using, and then reusing existing functions across different places in the repository, being able to successfully leverage auxiliary methods is key.\nCurrent instruction-following LLMs are generally fine-tuned with data consisting of self-contained code snippets without the interaction and learning of function usages.\nThis is further exacerbated by prior benchmarks, which mostly use self-contained functions, thus cannot expose the insufficient tool-using capability of such models.\nIn EvoEval, with Tool_Use and Tool_Use-Main_Only, we demonstrate this gap in evaluation and hope to inspire future research on this important aspect of code LLMs."
        },
        {
            "section_id": "6",
            "parent_section_id": null,
            "section_name": "Related Work",
            "text": "Large language models for code.\nStarting with the general development of LLMs for general purpose tasks, developers have applied LLMs to perform code-related tasks by further training LLMs using collected code snippets from open-source repositories.\nSuch LLMs include Codex [10  ###reference_b10###], PolyCoder [52  ###reference_b52###], CodeT5 [48  ###reference_b48###], CodeGen [34  ###reference_b34###], InCoder [14  ###reference_b14###], CodeLlama [40  ###reference_b40###], StarCoder [26  ###reference_b26###], StarCoder2 [29  ###reference_b29###], DeepSeeker [16  ###reference_b16###], etc.\nThese LLMs can autoregressive complete code given the relevant prefix (e.g., docstrings for function completion).\nMore recently, following the advancement in NLP, researchers have applied instruction-tuning methods to train code-specific LLMs that are well-versed in following instructions.\nExamples of such LLMs include CodeLlama-Inst [40  ###reference_b40###] and DeepSeeker-Inst [16  ###reference_b16###].\nWizardCoder [30  ###reference_b30###] instruction-tunes the model using Evol-Instruct to create more complex instructions.\nMagicoder [50  ###reference_b50###] develops OSS-Instruct by synthesizing high quality instruction data from open-source code snippets.\nOpenCodeInterpreter [55  ###reference_b55###] additionally leverages execution feedback for instruction-tuning in order to better support multi-turn code generation and refinement.\nProgram synthesis benchmarking.\nHumanEval [10  ###reference_b10###] and MBPP [4  ###reference_b4###] are two of the most widely-used handcrafted code generation benchmarks complete with test cases to check for the correctness of LLM outputs.\nBuilding on these popular benchmarks, additional variants have been crafted including: HumanEval+ [28  ###reference_b28###] which improves the two benchmarks with more complete testcases;\nHumanEval-X [54  ###reference_b54###] which extends HumanEval to C++, Javascript and Go;\nMultiPL-E [9  ###reference_b9###] which further extends both HumanEval and MBPP to 18 coding languages.\nSimilarly, other benchmarks have been developed for specific domains: DS-1000 [25  ###reference_b25###] and Arcade [53  ###reference_b53###] for data science APIs;\nODEX [49  ###reference_b49###] for open-domain code generation covering a diverse range of libraries;\nCodeContests [27  ###reference_b27###], APPS [17  ###reference_b17###] and LiveCodeBench [20  ###reference_b20###] for programming contests; ClassEval [13  ###reference_b13###] for class-level generations, and SWE-Bench [23  ###reference_b23###] for real-world software engineering tasks.\nDifferent from prior benchmarks which require handcraft problems from scratch – high manual effort or scrape open-source repositories or coding contest websites – leading to unavoidable data leakage,\nEvoEval directly uses LLMs to evolve existing benchmark problems to create new complex evaluation problems.\nFurthermore, contrasting with the narrow scope of prior benchmarks (often focusing on a single type or problem, i.e., coding contests), EvoEval utilizes targeted transformation to evolve problems into different domains, allowing for a more holistic evaluation of program synthesis using LLMs."
        },
        {
            "section_id": "7",
            "parent_section_id": null,
            "section_name": "Conclusion",
            "text": "We present EvoEval– a set of program synthesis benchmarks created by evolving existing problems into different target domains.\nWe build on top of the popular HumanEval benchmark to produce 828 problems across 7 different benchmarks for a holistic and comprehensive evaluation of LLM program synthesis ability.\nOur results on 51 LLMs show that compare to high performance on standard benchmarks, there is drastic drop in performance (on average 39.4%) when evaluated on EvoEval.\nAdditionally, we observe significant ranking differences compared to previous leaderboards, indicating potential overfitting of popular LLMs on existing benchmarks.\nThroughout the paper, we provide additional insights, including the brittleness of instruction-following LLMs as well as problem composition and decomposition abilities.\nWe hope EvoEval not only provides a valuable benchmarking suite for program synthesis but also inspires future code LLM builders to recognize the shown limitations of existing code LLMs and develop novel and targeted training approaches for code.\nWe have open-sourced the EvoEval benchmarks, tools, and complete LLM generations available at https://github.com/evo-eval/evoeval  ###reference_###"
        },
        {
            "section_id": "8",
            "parent_section_id": null,
            "section_name": "Acknowledgment",
            "text": "We thank Owen Colegrove for his help on starting this project and providing valuable feedback throughout, Jiawei Liu for providing helpful discussions and Yifeng Ding for his help in running experiments."
        }
    ]
}